---
title: "OBmap 3D"
author: "kanazian"
date: "`r Sys.Date()`"
output: html_document
always_allow_html: true
---
# Goal:
Create a 3D reconstruction of single dimension targeted transcriptomics data in order to calculate the position (not necessarily a specific voxel but moreso a domain-like area) of an ORs two glomeruli.

## Prior Steps:
Input TPM data is gencode v25 aligned, RSEM quantified and merged using make_obmtx.Rmd file. Input voxels are based on MRI model which is transformed to 3D coordinates using mri_OB_cubed.Rmd file. Weights are calculated based on the number of voxels in that section for each dimension. Line of glomeruli mirror symmetry was calculated from two-peak AP and ML positions using ob_heatmaps.Rmd file. 

## Plan:
Use best 2 replicates (1 and 2) to generate the statistical model with 200 iterations (more iter will require running on server or adding more swap space).  Model involves ILR transform of dirichlet sampled TPM data which is then used to calculate Bayesian posterior probabilities for each OR in each voxel. p50 quantile value will be used to calculate most likely positions for each OR. To avoid picking a point that is an intersection of high expression sections in each dimension, a clustering function is used to determine high expression areas. A dorsal-ventral constraint function based on prior knowledge of an ORs position in the olfactory epithelium is combined with predicted OB positions in order to ensure 2 matching DV predictions if at least one predicted position matches with olfactory epithelium position.  

# Packages and functions
```{r setup, message=F}
#knitr::opts_chunk$set(warning=F)
library(tictoc)
library(MCMCpack)
library(plotly) 
library(tidyverse)
library(driver) # devtools::install_github("jsilve24/driver")
library(Rcpp)
library(ggsci)
library(cowplot)
library(magrittr)
#detach("package:vegan", unload=TRUE)

# functions -----------------------------------------------------------
# model prep
SampleData <- function(Y, alpha, iter=1){
  d <- array(0, dim=c(N, D, iter))
  for (i in 1:nrow(Y)){
    d[i,,] <- t(rdirichlet(iter, Y[i,] + alpha[i,]))
  } #endfor
  return(d)
} #end SampleData

# calculate quantiles
sourceCpp("~/Desktop/obmap/r_analysis/data/3dimOB/model/kzcolQuant.cpp")

#function for distance between 3d points
Dist3d <- function(df1, df2, row1, row2) {
  thing <- sqrt((df1$AntPos[row1] - df2$AntPos[row2])^2 +
                  (df1$MedLat[row1] - df2$MedLat[row2])^2 + 
                  (df1$VenDor[row1] - df2$VenDor[row2])^2)
  return(thing)
} #end Dist3d

# 3d interactive scatterplot
Scat3d <- function(df, ml, ap, vd, color="voxrankperOR") {
  plot_ly(df, 
          x = ml, 
          y = ap, 
          z = vd, 
          color = color,
          text = ~paste('Gene:', olfrname, 
                        '<br>Rank:', voxrankperOR,
                        '<br>p50:', p50),
          marker = list(size = 6,
                        line = list(color = 'black',
                                    width = 0.5)),
          type = 'scatter3d',
          mode = 'markers') %>%
    layout(scene = list(xaxis = list(title = 'Medial-Lateral'),
                        yaxis = list(title = 'Anterior-Posterior'),
                        zaxis = list(title = 'Ventral-Dorsal')))
} #end Scat3d

#given an OR, pick a number of high probability voxels based on signal to noise ratios
Scat_rank <- function(olfr, topX = 72, out = "plot", title = NA) {
  reranked <- ranked %>% 
    filter(olfrname == olfr) %>% 
    mutate(rankofrank = min_rank(voxRankSNR),
           rankcol = min_rank(desc(ifelse(rankofrank <= topX, rankofrank, NA))),
           isRanked = is.na(rankcol))
  
  besties <- reranked %>% filter(isRanked == 0) %>% arrange(voxRankSNR)
  worsties <- reranked %>% filter(isRanked == 1)
  all <- bind_rows(besties, worsties)
  
  if (out == "data") {
    return(all)
  } else {
    p <- plot_ly(type = "scatter3d", mode = "markers") %>% 
      add_trace(data=worsties, x=~AntPos, y=~MedLat, z=~VenDor, 
                color=~rankcol, opacity=0.15,
                text = ~paste('Gene:', olfrname, 
                              '<br>voxRankSNR:', voxRankSNR, 
                              '<br>voxSNRdim', voxSNRdim),
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=besties, x=~AntPos, y=~MedLat, z=~VenDor, color=~rankcol,
                text = ~paste('Gene:', olfrname, 
                              '<br>voxRankSNR:', voxRankSNR, 
                              '<br>voxSNRdim', voxSNRdim),
                marker = list(size = 6, line = list(color = 'black', width = 0.5))) %>%
      layout(title = title,
             scene = list(xaxis = list(title = 'Anterior-Posterior'),
                          yaxis = list(title = 'Medial-Lateral'),
                          zaxis = list(title = 'Ventral-Dorsal')))
    return(p)
  } #endif
} #end Scat_rank

#plot p50 values for an olfrs top X voxels
p50plot <- function(olfr, rankx = 50, title = NA) {
  bestp50 <- ranked %>% 
    filter(olfrname == olfr) %>% 
    mutate(rankp = min_rank(desc(p50))) %>% filter(rankp <= rankx)
  worstp50 <- ranked %>% 
    filter(olfrname == olfr) %>% mutate(rankp = min_rank(p50)) %>% 
    filter(rankp > rankx) %>% mutate(rankna = NA)
  plot_ly(type = "scatter3d", mode = "markers") %>% 
    add_trace(data=worstp50, x=~AntPos, y=~MedLat, z=~VenDor, 
              color="shell", opacity=0.15,
              text = ~paste('Gene:', olfr, 
                            '<br>voxRankSNR:', voxRankSNR, 
                            '<br>voxSNRdim', voxSNRdim),
              marker = list(size = 5, color = "grey")) %>%
    add_trace(data=bestp50, x=~AntPos, y=~MedLat, z=~VenDor, color=~rankp,
              text = ~paste('Gene:', olfr, 
                            '<br>voxRankSNR:', voxRankSNR, 
                            '<br>voxSNRdim', voxSNRdim),
              marker = list(size = 6, line = list(color = 'black', width = 0.5))) %>%
    layout(title = title,
           scene = list(xaxis = list(title = 'Anterior-Posterior'),
                        yaxis = list(title = 'Medial-Lateral'),
                        zaxis = list(title = 'Ventral-Dorsal')))
} #end p50plot

#define clusters of best X p50 points using a pairwise matrix and ability to output plots and data
#given a number of top ranking positions for an OR, cluster the points based on spatial position
#why the hell am i ranking just to rerank with desc???
Cluster <- function(olfr, df, topX = 25, 
                    minClustSize = 3, distX = 3,
                    out = "plot", title = NA) {
  df_in <- df %>% 
    filter(olfrname == olfr) %>% 
    mutate(rankofrank = min_rank(desc(p50))) %>% 
    filter(rankofrank <= topX) %>% 
    arrange(desc(p50))
  
  #make pairwise matrixes
  dmatrix <- matrix(data = 0, nrow = nrow(df_in), ncol = nrow(df_in))
  for (i in 1:nrow(df_in)) {
    distances <- vector("numeric", length = nrow(df_in))
    toprankvox <- df_in$voxel[i]
    ap <- df_in$AntPos[i]
    ml <- df_in$MedLat[i]
    vd <- df_in$VenDor[i]
    for (j in 1:nrow(df_in)) {
      if (i == j) {
        distances[j] <- 0
      } else {
        distances[j] <- sqrt((df_in$AntPos[i] - df_in$AntPos[j])^2 + 
                               (df_in$MedLat[i] - df_in$MedLat[j])^2 +
                               (df_in$VenDor[i] - df_in$VenDor[j])^2)
      } #endif
    } #endf_inorj
    neighbors <- which(distances <= sqrt(distX))
    dmatrix[neighbors, i] <- 1
  } #endf_inori
  
  #cluster matrix
  cluster_list <- rep(NA, nrow(df_in))
  for (k in 1:ncol(dmatrix)) {
    neighinit <- 0
    neighlenchange <- 1
    neigh <- which(dmatrix[,k] == 1)
    #do a bunch of rounds, find a way to have it run until it stops finding new points
    while (neighlenchange != 0) {
      #for each neighbor of previous round of neighbors, find new neighbors
      for (l in 1:length(neigh)) {
        neigh <- c(neigh, which(dmatrix[,neigh[l]] == 1))
        neigh <- sort(neigh[-which(duplicated(neigh))])
      } #endforl
      neighlen <- length(neigh)
      neighlenchange <- neighlen - neighinit
      neighinit <- neighlen
    } #endwhile
    cluster_list[neigh] <- k
  } #endfork
  
  df_out <- df_in %>% mutate(rawclust = cluster_list) %>% 
    group_by(rawclust) %>% 
    mutate(clustmaxp = max(p50), 
           clustminp = min(p50), 
           clustmeanp = mean(p50)) %>%
    add_tally() %>%
    ungroup() %>%
    filter(n >= minClustSize) %>%
    mutate(clustmaxprank = dense_rank(desc(clustmaxp)), 
           clustmeanprank = dense_rank(desc(clustmeanp)), 
           clustsizerank = dense_rank(desc(n))) %>% 
    arrange(clustsizerank) %>%
    mutate(isCluster = T,
           clust_unique = paste(olfrname, clustmaxprank, sep = "_")) %>%
    select(p2.5:ORrankpervox, 
           rankofrank, 
           voxel,
           rawclust:clustsizerank, 
           clust_unique, 
           isCluster) %>%
    filter(isCluster == T) %>%
    arrange(clustmaxprank)
  
  df_voxels <- df_out %>% pull(voxel)
  
  cut_out <- df %>% 
    filter(olfrname == olfr) %>% 
    mutate(rankofrank = min_rank(desc(min_rank(p50)))) %>% 
    filter(voxel %notin% df_voxels) %>% 
    mutate(rawclust = NA,
           clustmaxp = NA,
           clustminp = NA,
           clustmeanp = NA,
           n = NA,
           clustmeanprank = NA,
           clustmaxprank = NA,
           clustsizerank = NA,
           isCluster = 0,
           clust_unique = NA) %>%
    select(p2.5:ORrankpervox, 
           rankofrank, 
           voxel,
           rawclust:clustsizerank, 
           clust_unique, 
           isCluster)
  
  all_out <- bind_rows(df_out, cut_out) %>% 
    unique()
  
  #return various things 'rgb(10,10,10)'
  if (str_detect(tolower(out), "data")) {
    return(all_out)
  } else if (str_detect(tolower(out), "best")) {
    return(df_out)  
  } else  {
    p <-  plot_ly(type = "scatter3d", mode = "markers") %>% 
      add_trace(data=cut_out, x=~AntPos, y=~MedLat, z=~VenDor, 
                color="shell", opacity=0.15,
                text = ~paste('Gene:', olfrname, 
                              '<br>C_size_rank:', clustsizerank, 
                              '<br>C_mean_p50:', round(clustmeanp, digits = 5),
                              '<br>C_max_p50:', round(clustmaxp, digits = 5),
                              '<br>Cluster:', clust_unique),
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=df_out, x=~AntPos, y=~MedLat, z=~VenDor, color=~clustmaxprank,
                text = ~paste('Gene:', olfrname, 
                              '<br>C_size_rank:', clustsizerank, 
                              '<br>C_mean_p50:', round(clustmeanp, digits = 5),
                              '<br>C_max_p50:', round(clustmaxp, digits = 5),
                              '<br>Cluster:', clust_unique),
                marker = list(size = 6, line = list(color = 'black', width = 0.5))) %>%
      layout(title = title,
             scene = list(xaxis = list(title = 'Anterior-Posterior'),
                          yaxis = list(title = 'Medial-Lateral'),
                          zaxis = list(title = 'Ventral-Dorsal')))
    return(p)
  } #endif
} #end Cluster


# Call Cluster on relevant (gene family, OEDV) OB positions
# Positions close to the symline are tested against medial+lateral positions in terms of p50 and if more probably, will return a single cluster along the symline
# Symconstrain determines whether the M or L cluster is more probable and then seeks out a new cluster for the less probable side along a restricted area
PredGloms <- function(olfr, topMin = 20, topBy = 10, 
                       minSize = 3, clustOut = 1, 
                       symconstrain = F, symcshift = 6, 
                       symline = T, verbose = F,
                       out = "plot", title = NA) {
  if (verbose == T) print(olfr)
  clustFound <- 0
  topStep <- topMin
  while (clustFound < clustOut) {
    if (!str_detect(olfr, "Olfr")) {
      df_lat <- Cluster(olfr, df = ranked_LD, 
                        topX = topStep, minClustSize = minSize, 
                        out = "best") %>% 
        mutate(side = "Lat", step = topStep, quack = "raw")
      df_med <- Cluster(olfr, df = ranked_MD, 
                        topX = topStep, minClustSize = minSize, 
                        out = "best") %>% 
        mutate(side = "Med", step = topStep, quack = "raw")
      
      if (symconstrain == T) {
        if (max(df_lat$p50) > max(df_med$p50)) {
          best_latAP <- df_lat %>% 
            filter(p50 == clustmaxp) %>%
            filter(clustmaxprank == 1) %>%
            pull(AntPos) 
          if (best_latAP > 20) {
            best_latAP <- 20
          } #endif best_latAP too posterior
          best_latML <- df_lat %>% 
            filter(p50 == clustmaxp) %>%
            filter(clustmaxprank == 1) %>%
            pull(MedLat)
          sc_ranked <- ranked %>%
            filter(between(AntPos, best_latAP + 1, best_latAP + symcshift)) %>%
            filter(MedLat < best_latML) %>%
            filter(VenDor >= 11) %>%
            filter(symside == "Medial")
          df_med <- Cluster(olfr, df = sc_ranked,
                            topX = topStep, minClustSize = minSize,
                            out = "best") %>% 
            mutate(side = "Med", step = topStep, quack = "SCLat")
        } else {
          best_medAP <- df_med %>% 
            filter(p50 == clustmaxp) %>%
            filter(clustmaxprank == 1) %>%
            pull(AntPos)
          if (best_medAP < 4) {
            best_medAP <- 4
          } #endif best_latAP too posterior
          best_medML <- df_med %>% 
            filter(p50 == clustmaxp) %>%
            filter(clustmaxprank == 1) %>%
            pull(MedLat)
          sc_ranked <- ranked %>%
            filter(between(AntPos, best_medAP - symcshift, best_medML - 1)) %>%
            filter(MedLat > best_medML) %>%
            filter(VenDor >= 11) %>%
            filter(symside == "Lateral")
          df_lat <- Cluster(olfr, df = sc_ranked,
                            topX = topStep, minClustSize = minSize,
                            out = "best") %>% 
            mutate(side = "Lat", step = topStep, quack = "SCMed")
        } #endif lat vs med notOR
        
        df_all <- bind_rows(df_lat, df_med) %>%
          filter(clustmaxprank <= clustOut)
        
      } else {
        df_all <- bind_rows(df_lat, df_med) %>%
          filter(clustmaxprank <= clustOut)
      } #endif symconstrain, notOR
      if (symline == T) {
        df_sym <- Cluster(olfr, df = ranked_SD,
                          topX = topStep, minClustSize = minSize*2,
                          out = "best") %>%
          mutate(side = "Symline", step = topStep, quack = "sym")
        
        if (max(df_sym$p50) >= max(df_all$p50)) {
          df_all <- df_sym %>%
            mutate(pgStatus = "Symline-NotOR",
                   pgMaxRatio = max(df_sym$p50)/max(df_all$p50)) %>%
            filter(clustmaxprank <= clustOut)
        } else {
          df_all <- df_all  %>%
            mutate(pgStatus = "NotOR",
                   pgMaxRatio = max(df_all$p50)/max(df_sym$p50))
        } #endif symcheck, notOR
      }
    } else {
      
      DVpos <- DVinfo %>%
        filter(olfrname == olfr) %>%
        pull(DVdiscord)
      DVcertainty <- DVinfo %>%
        filter(olfrname == olfr) %>%
        pull(DVcertainty)
      
      if (DVpos[1] == "Unusual") {
        df_all <- Cluster(olfr, df = ranked_unu,
                          topX = topStep, minClustSize = minSize*2,
                          out = "best") %>%
          filter(clustmaxprank <= clustOut) %>%
          mutate(side = "Unusual", step = topStep, quack = "raw",
                 pgStatus = "Unusual", pgMaxRatio = NA)
        
      } else if (DVpos[1] == "Dorsal") {
        df_lat <- Cluster(olfr, df = ranked_LD, 
                          topX = topStep, minClustSize = minSize, 
                          out = "best") %>% 
          mutate(side = "Lat", step = topStep, quack = "raw")
        df_med <- Cluster(olfr, df = ranked_MD, 
                          topX = topStep, minClustSize = minSize, 
                          out = "best") %>% 
          mutate(side = "Med", step = topStep, quack = "raw")
        
        if (symconstrain == T) {
          if (max(df_lat$p50) > max(df_med$p50)) {
            best_latAP <- df_lat %>% 
              filter(p50 == clustmaxp) %>%
              filter(clustmaxprank == 1) %>%
              pull(AntPos)
            if (best_latAP > 20) {
              best_latAP <- 20
            } #endif best_latAP too posterior
            best_latML <- df_lat %>% 
              filter(p50 == clustmaxp) %>%
              filter(clustmaxprank == 1) %>%
              pull(MedLat)
            sc_ranked <- ranked %>%
              filter(between(AntPos, best_latAP + 1, best_latAP + symcshift)) %>%
              filter(MedLat < best_latML) %>%
              filter(VenDor >= 11) %>%
              filter(symside == "Medial")
            df_med <- Cluster(olfr, df = sc_ranked,
                              topX = topStep, minClustSize = minSize,
                              out = "best") %>%
              mutate(side = "Med", step = topStep, quack = "SCLat")
          } else {
            best_medAP <- df_med %>% 
              filter(p50 == clustmaxp) %>%
              filter(clustmaxprank == 1) %>%
              pull(AntPos)
            if (best_medAP < 4) {
              best_medAP <- 4
            } #endif best_latAP too posterior
            best_medML <- df_med %>% 
              filter(p50 == clustmaxp) %>%
              filter(clustmaxprank == 1) %>%
              pull(MedLat)
            sc_ranked <- ranked %>%
              filter(between(AntPos, best_medAP - symcshift, best_medAP - 1)) %>%
              filter(MedLat > best_medML) %>%
              filter(VenDor >= 11) %>%
              filter(symside == "Lateral")
            df_lat <- Cluster(olfr, df = sc_ranked,
                              topX = topStep, minClustSize = minSize,
                              out = "best") %>%
              mutate(side = "Lat", step = topStep, quack = "SCMed")
          } #endif lat vs med dorsalOR
          
          df_all <- bind_rows(df_lat, df_med) %>%
            filter(clustmaxprank <= clustOut)
          
        } else {
          df_all <- bind_rows(df_lat, df_med) %>%
            filter(clustmaxprank <= clustOut)
        } #endif symconstrain, dorsalOR
        if (symline == T) {
          df_sym <- Cluster(olfr, df = ranked_SD,
                            topX = topStep, minClustSize = minSize*2,
                            out = "best") %>%
            mutate(side = "Symline", step = topStep, quack = "sym")
          if (max(df_sym$p50) >= max(df_all$p50)) {
            df_all <- df_sym %>%
              mutate(pgStatus = "Symline-Dorsal",
                     pgMaxRatio = max(df_sym$p50)/max(df_all$p50)) %>%
              filter(clustmaxprank <= clustOut)
          } else {
            df_all <- df_all  %>%
              mutate(pgStatus = "Dorsal",
                     pgMaxRatio = max(df_all$p50)/max(df_sym$p50))
          }
        } #endif symcheck, dorsalOR
      } else if (DVpos[1] == "Ventral") {
        df_lat <- Cluster(olfr, df = ranked_LV, 
                          topX = topStep, minClustSize = minSize, 
                          out = "best") %>% 
          mutate(side = "Lat", step = topStep, quack = "raw")
        df_med <- Cluster(olfr, df = ranked_MV, 
                          topX = topStep, minClustSize = minSize, 
                          out = "best") %>% 
          mutate(side = "Med", step = topStep, quack = "raw")
        
        if (symconstrain == T) {
          if (max(df_lat$p50) > max(df_med$p50)) {
            best_latAP <- df_lat %>% 
              filter(p50 == clustmaxp) %>%
              filter(clustmaxprank == 1) %>%
              pull(AntPos)
            if (best_latAP > 20) {
              best_latAP <- 20
            } #endif best_latAP too posterior
            best_latML <- df_lat %>% 
              filter(p50 == clustmaxp) %>%
              filter(clustmaxprank == 1) %>%
              pull(MedLat)
            sc_ranked <- ranked %>%
              filter(between(AntPos, best_latAP + 1, best_latAP + symcshift)) %>%
              filter(MedLat < best_latML) %>%
              filter(VenDor < 11) %>%
              filter(symside == "Medial")
            df_med <- Cluster(olfr, df = sc_ranked,
                              topX = topStep, minClustSize = minSize,
                              out = "best") %>%
              mutate(side = "Med", step = topStep, quack = "SCLat")
          } else {
            best_medAP <- df_med %>% 
              filter(p50 == clustmaxp) %>%
              filter(clustmaxprank == 1) %>%
              pull(AntPos)
            if (best_medAP < 4) {
              best_medAP <- 4
            } #endif best_latAP too posterior
            best_medML <- df_med %>% 
              filter(p50 == clustmaxp) %>%
              filter(clustmaxprank == 1) %>%
              pull(MedLat)
            sc_ranked <- ranked %>%
              filter(between(AntPos, best_medAP - symcshift, best_medAP - 1)) %>%
              filter(MedLat > best_medML) %>%
              filter(VenDor < 11) %>%
              filter(symside == "Lateral")
            df_lat <- Cluster(olfr, df = sc_ranked,
                              topX = topStep, minClustSize = minSize,
                              out = "best") %>%
              mutate(side = "Lat", step = topStep, quack = "SCMed")
          } #endif lat vs med, ventralOR
          
          df_all <- bind_rows(df_lat, df_med) %>%
            filter(clustmaxprank <= clustOut)
          
        } else {
          df_all <- bind_rows(df_lat, df_med) %>%
            filter(clustmaxprank <= clustOut)
        } #endif symconstrain, ventralOR
        if (symline == T) {
          df_sym <- Cluster(olfr, df = ranked_SV,
                            topX = topStep, minClustSize = 5,
                            out = "best") %>%
            mutate(side = "Symline", step = topStep, quack = "sym")
          if (max(df_sym$p50) >= max(df_all$p50)) {
            df_all <- df_sym %>%
              mutate(pgStatus = "Symline-Ventral",
                     pgMaxRatio = max(df_sym$p50)/max(df_all$p50)) %>%
              filter(clustmaxprank <= clustOut)
          } else {
            df_all <- df_all  %>%
              mutate(pgStatus = "Ventral",
                     pgMaxRatio = max(df_all$p50)/max(df_sym$p50))
          }
        } #endif symmcheck, ventralOR
      } #endif DVpos[1]
    } #endif not notOR
    
    cuflist <- df_all %>% 
      mutate(cuf = paste(clust_unique, side, sep = "_")) %>%
      select(cuf) %>%
      unique() %>%
      pull(cuf)
    
    if (nrow(df_all) == 0) {
      clustFound <- 0
    } else if (str_detect(cuflist[1], "Unusual")) {
      clustFound <- length(cuflist)
    } else if (str_detect(cuflist[1], "Symline")) {
      clustFound <- length(cuflist)
    } else {
      clustFound <- length(cuflist)/2
    } #endif Unusual only needs 1 glom
    
    if (verbose == T) {
      if (clustFound < clustOut) {
        print(paste(topStep, NA))
      } else {
        print(topStep)
      } #endif
    } #endif
    topStep <- topStep + topBy
  } #endwhile
  
  df_best <- df_all %>%
    mutate(fadenotbest = ifelse(p50 == clustmaxp, 1 , 0))
  
  #output
  if (out == "data") {
    return(df_best)
  } else {
    p <- plot_ly(type = "scatter3d", mode = "markers") %>%
      add_trace(data=blankdata, x=~AntPos, y=~MedLat, z=~VenDor,
                color="shell", opacity=0.1,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=df_best %>% filter(fadenotbest == 1), 
                x=~AntPos, y=~MedLat, z=~VenDor, 
                color="Best Probability",
                text = ~paste('Gene:', olfrname,
                              '<br>C_size_rank:', clustsizerank,
                              '<br>C_max_p50:', clustmaxp),
                marker = list(size = 6, color = "red", 
                              line = list(color = 'black', width = 0.5))) %>%
      add_trace(data=df_best %>% filter(fadenotbest == 0), 
                x=~AntPos, y=~MedLat, z=~VenDor, 
                color="High Probability",  opacity=0.6,
                text = ~paste('Gene:', olfrname,
                              '<br>C_size_rank:', clustsizerank,
                              '<br>C_max_p50:', clustmaxp),
                marker = list(size = 6, color = "orange", 
                              line = list(color = 'black', width = 0.5))) %>%
      layout(title = title,
             scene = list(xaxis = list(title = 'Anterior-Posterior'),
                          yaxis = list(title = 'Medial-Lateral'),
                          zaxis = list(title = 'Ventral-Dorsal')))
    return(p)
  } #endif out
} #end PredGloms

#call PredGloms on a list
PredList <- function(x, topByN = 10, minSizeN = 3, 
                     symconstrainTF = F, symcshiftN = 6,
                     symlineTF = T, verboseTF = F, 
                     out = "plot", title = NA) {
  #use a list to build a df of unknown size instead of bind_row each iteration
  list_out <- vector("list", length = length(x))
  for (i in 1:length(x)) {
    list_out[[i]] <- PredGloms(x[i], topBy = topByN, minSize = minSizeN, 
                               symconstrain = symconstrainTF, symcshift = symcshiftN,
                               verbose = verboseTF, 
                               symline = symlineTF, out = "data")
  } #endfori
  
  df_out <- bind_rows(list_out)
  
  #output
  if (str_detect(tolower(out), "data")) {
    return(df_out)
  } else if (str_detect(tolower(out), "point")) {
    df_point <- df_out %>% filter(p50 == clustmaxp)
    p <- plot_ly(type = "scatter3d", mode = "markers") %>% 
      add_trace(data=blankdata, x=~AntPos, y=~MedLat, z=~VenDor, 
                color="shell", opacity=0.15,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=df_point, x=~AntPos, y=~MedLat, z=~VenDor, color=~olfrname,
                text = ~paste('Gene:', olfrname, 
                              '<br>C_size_rank:', clustsizerank, 
                              '<br>C_max_p50:', clustmaxp),
                marker = list(size = 6, line = list(color = 'black', width = 0.5))) %>%
      layout(title = title,
             scene = list(xaxis = list(title = 'Anterior-Posterior'),
                          yaxis = list(title = 'Medial-Lateral'),
                          zaxis = list(title = 'Ventral-Dorsal')))
    return(p)
  } else {
    p <- plot_ly(type = "scatter3d", mode = "markers") %>% 
      add_trace(data=blankdata, x=~AntPos, y=~MedLat, z=~VenDor, 
                color="shell", opacity=0.15,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=df_out, x=~AntPos, y=~MedLat, z=~VenDor, color=~olfrname,
                text = ~paste('Gene:', olfrname, 
                              '<br>C_size_rank:', clustsizerank, 
                              '<br>C_max_p50:', clustmaxp),
                marker = list(size = 6, line = list(color = 'black', width = 0.5))) %>%
      layout(title = title,
             scene = list(xaxis = list(title = 'Anterior-Posterior'),
                          yaxis = list(title = 'Medial-Lateral'),
                          zaxis = list(title = 'Ventral-Dorsal')))
    return(p)
  } #endif
} #end PredList

#make pub plots
#obviously stands for Player Unknown's Battle Glomeruli
PUBG <- function(olfrS, symconstrainTF = T, symlineTF = T, topByN = 5, 
                  face = "Dorsal", color_best = "red", color_notbest = "yellow") {
  
  pgout <- PredGloms(olfr = olfrS, topBy = topByN, 
                     symconstrain = symconstrainTF, 
                     symline = symlineTF, out = "data")
  
  if (face == "Dorsal") {
    face_pg <- pgout %>% filter(VenDor >= 1) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    blank_pg <- blankdata %>% filter(VenDor > 14) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    blank_hidden <- blankdata %>% filter(VenDor <= 14) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    p <- plot_ly(type = "scatter3d", mode = "markers") %>%
      add_trace(data=blank_pg, x=~AntPos, y=~MedLat, z=~VenDor,
                color="shell", opacity=0.2,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=blank_hidden, x=~AntPos, y=~MedLat, z=~VenDor,
                color="shell", opacity=0,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=face_pg %>% filter(fadenotbest == 1), 
                x=~AntPos, y=~MedLat, z=~VenDor, 
                color="Best Probability",
                marker = list(size = 8, color = color_best, 
                              line = list(color = 'black', width = 1))) %>%
      add_trace(data=face_pg %>% filter(fadenotbest == 0), 
                x=~AntPos, y=~MedLat, z=~VenDor, 
                color="High Probability",  opacity=0.6,
                marker = list(size = 6, color = color_notbest, 
                              line = list(color = 'black', width = 0.5))) %>%
      layout(scene = list(xaxis = list(visible = F),
                          yaxis = list(visible = F),
                          zaxis = list(visible = F)))
    return(p)
  } else if (face == "Medial") {
    face_pg <- pgout %>% filter(MedLat < 10) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    blank_pg <- blankdata %>% filter(MedLat < 10) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    blank_hidden <- blankdata %>% filter(MedLat >= 10) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    p <- plot_ly(type = "scatter3d", mode = "markers") %>%
      add_trace(data=blank_pg, x=~AntPos, y=~MedLat, z=~VenDor,
                color="shell", opacity=0.2,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=blank_hidden, x=~AntPos, y=~MedLat, z=~VenDor,
                color="shell", opacity=0,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=face_pg %>% filter(fadenotbest == 1), 
                x=~AntPos, y=~MedLat, z=~VenDor, 
                color="Best Probability",
                marker = list(size = 8, color = color_best, 
                              line = list(color = 'black', width = 1))) %>%
      add_trace(data=face_pg %>% filter(fadenotbest == 0), 
                x=~AntPos, y=~MedLat, z=~VenDor, 
                color="High Probability",  opacity=0.6,
                marker = list(size = 6, color = color_notbest, 
                              line = list(color = 'black', width = 0.5))) %>%
      layout(scene = list(xaxis = list(visible = F),
                          yaxis = list(visible = F),
                          zaxis = list(visible = F)))
    return(p)
  } else if (face == "Lateral") {
    face_pg <- pgout %>% filter(MedLat > 8) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    blank_pg <- blankdata %>% filter(MedLat > 8) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    blank_hidden <- blankdata %>% filter(MedLat <= 8) %>%
      mutate(newML = 23-MedLat) %>%
      select(-MedLat) %>%
      rename(MedLat = newML)
    p <- plot_ly(type = "scatter3d", mode = "markers") %>%
      add_trace(data=blank_pg, x=~AntPos, y=~MedLat, z=~VenDor,
                color="shell", opacity=0.2,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=blank_hidden, x=~AntPos, y=~MedLat, z=~VenDor,
                color="shell", opacity=0,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=face_pg %>% filter(fadenotbest == 1), 
                x=~AntPos, y=~MedLat, z=~VenDor, 
                color="Best Probability",
                marker = list(size = 8, color = color_best, 
                              line = list(color = 'black', width = 1))) %>%
      add_trace(data=face_pg %>% filter(fadenotbest == 0), 
                x=~AntPos, y=~MedLat, z=~VenDor, 
                color="High Probability",  opacity=0.6,
                marker = list(size = 6, color = color_notbest, 
                              line = list(color = 'black', width = 0.5))) %>%
      layout(scene = list(xaxis = list(visible = F),
                          yaxis = list(visible = F),
                          zaxis = list(visible = F)))
    return(p)
  } #endif face
} #end PUBG

`%notin%` <- Negate(`%in%`)
```


# Load info and features
Both sexes represented in each dimensional group.
Line of glomeruli symmetry determined from 1D AP,ML heatmap mean of top 2 peaks
```{r, warning=F}
info <- read_csv("~/Desktop/info_210430.csv")

symline <- read_csv("~/Desktop/obmap/r_analysis/data/3dimOB/model/symline_3rep.csv") %>%
  mutate(mlvals9 = mlvals*0.9, mlvals8 = mlvals*0.8, mlvalsX = mlvals * (1 - (apvals*0.04)))

blankdata <- readRDS("~/Desktop/obmap/r_analysis/data/mri_to_R/210428_voxV4_strip25_straightMdoubled_outeronly_rescaled22dv.RDS") %>% unique() %>% mutate(catname = paste(AntPos, MedLat, VenDor, sep = "-"))

filterORs <- readRDS("~/Desktop/heatmaps/filterORs_ompdv22no1315_uni2_ect4_below1mingt_zer0.RDS")

kzY <- read_csv("~/Desktop/obmap/r_analysis/data/make_TPMmtx/covarintactchemo3_over_samples_210429.csv", col_names = TRUE) %>% 
  select(-contains("Vmn")) %>%
  select(-Omp, -Taf1b, -Xist)

#TRY MAKING A testOR
#make a testOR - Anterior, Dorsal, Medial and Middle, Ventral, Middle
testORs <- kzY %>% 
  select(name:dimrep) %>% 
  mutate(Olfr3_3_18_na = case_when(dim == "AntPos" & slice == 3 ~ 500,
                                dim == "AntPos" & slice == 2 ~ 250,
                                dim == "AntPos" & slice == 4 ~ 250,
                                dim == "MedLat" & slice == 3 ~ 500,
                                dim == "MedLat" & slice == 2 ~ 250,
                                dim == "MedLat" & slice == 4 ~ 250,
                                dim == "VenDor" & slice == 18 ~ 500,
                                dim == "VenDor" & slice == 17 ~ 250,
                                dim == "VenDor" & slice == 19 ~ 250,
                                dim == "AntPos" & slice == 2 ~ 500,
                                dim == "AntPos" & slice == 1 ~ 250,
                                dim == "AntPos" & slice == 3 ~ 250,
                                dim == "MedLat" & slice == 9 ~ 500,
                                dim == "MedLat" & slice == 8 ~ 250,
                                dim == "MedLat" & slice == 10 ~ 250,
                                dim == "VenDor" & slice == 17 ~ 500,
                                dim == "VenDor" & slice == 18 ~ 250,
                                dim == "VenDor" & slice == 16 ~ 250),
         Olfr3_3_18 = ifelse(is.na(Olfr3_3_18_na), 0, Olfr3_3_18_na)) %>%
  select(name, Olfr3_3_18)

kzYprep <- kzY %>%
  left_join(testORs, by = "name") %>% 
  filter(rep < 14) %>%
  filter(name != "M9S23") %>%
  filter(name != "M14S23") %>%
  arrange(rep, slice)
  
kzYgood <- kzYprep %>% 
  select(-name, -rep, -slice, -dim, -dimrep) %>% 
  select(-filterORs)
kzmY <- as.matrix(kzYgood)
rownames(kzmY) <- paste0("sample", 1:dim(kzYgood)[1])

N <- dim(kzmY)[1] #number of sections
D <- dim(kzmY)[2] #number of genes

# Voxel System
d1 <- 23 #antpost
d2 <- 22 #medlat
d3 <- 22 #vendor
```


# calculate weights
```{r}
#rdirichlet requires vector not dataframe so matrix the tibble
glomcounts <- read_csv("~/Desktop/obmap/r_analysis/data/3dimOB/model/allmice_covariates_trim_voxweights_v4.csv") %>% filter(name %in% kzYprep$name) %>% select(-rep, -slice, -dim) %>%
  rename("count.prop" = "weight")

#make covariates from 3d model
cntAP <- blankdata %>% group_by(AntPos) %>% summarise(voxels = n(), vox_norms_ratio2total = voxels/nrow(blankdata)) %>% mutate(dim = "AntPos") %>% rename("slice" = "AntPos")
cntML <- blankdata %>% group_by(MedLat) %>% summarise(voxels = n(), vox_norms_ratio2total = voxels/nrow(blankdata)) %>% mutate(dim = "MedLat") %>% rename("slice" = "MedLat")
cntVD <- blankdata %>% group_by(VenDor) %>% summarise(voxels = n(), vox_norms_ratio2total = voxels/nrow(blankdata)) %>% mutate(dim = "VenDor") %>% rename("slice" = "VenDor")
cntall <- bind_rows(cntAP, cntML) %>% bind_rows(cntVD)

voxweights <- kzYprep %>%  
  left_join(cntall, by = c("dim", "slice")) %>% 
  select(name:dimrep, voxels, vox_norms_ratio2total) %>%
  group_by(dim) %>%
  mutate(voxels_dim_mean = mean(voxels)) %>%
  ungroup() %>%
  rename("vox_r2t" = "vox_norms_ratio2total") %>%
  select(-voxels_dim_mean) %>%
  select(name, voxels, vox_r2t)

totaltpm_norms <- readRDS("~/Desktop/obmap/r_analysis/data/make_TPMmtx/totalORtpm_normalizations_justname_210404.RDS") %>%
  rename("rep_r2m" = "rep_norms_ratio2mean",
         "rep_r2t" = "rep_norms_ratio2total",
         "dim_r2m" = "dim_norms_ratio2mean",
         "dim_r2t" = "dim_norms_ratio2total")

omp_norms <- read_csv("~/Desktop/obmap/r_analysis/data/make_TPMmtx/weights_proptotal_210424.csv")

kzX <- omp_norms %>% 
  left_join(voxweights, by = "name") %>%
  mutate(ompdimvox = prop_dim_omp/vox_r2t,
         omprepvox = prop_rep_omp/vox_r2t,
         olfrdimvox = prop_dim_olfr/vox_r2t,
         olfrrepvox = prop_rep_olfr/vox_r2t) %>%
  mutate(weight = ompdimvox) %>%
  filter(name %in% kzYprep$name) %>%
  arrange(rep, slice)

# weightplotdat <- kzX %>% 
#   left_join(glomcounts, by = "name") %>% 
#   filter(dimrep == 1) %>%
#   select(dim, slice, sumolfr, sumomp, 
#          prop_dim_omp, prop_dim_olfr, vox_r2t, 
#          ompdimvox, olfrdimvox, count) %>%
#   group_by(dim) %>%
#   mutate(totcount = sum(count)) %>%
#   ungroup() %>%
#   mutate(propcount = count/totcount) %>%
#   select(dim, slice, prop_dim_omp, prop_dim_olfr, vox_r2t, propcount) %>%
#   rename("Total Olfr proportion" = prop_dim_olfr,
#          "OMP proportion" = prop_dim_omp,
#          "Voxel proportion" = vox_r2t,
#          "Counted glomeruli proportion" = propcount) %>%
#   pivot_longer(names_to = "metric",
#                values_to = "proportion",
#                cols = contains("proportion"))
# 
# weightplot <- weightplotdat %>%
#   filter(metric %in% c("Counted glomeruli proportion", "Voxel proportion")) %>%
#   ggplot() +
#   geom_line(aes(slice, proportion, color = metric)) +
#   labs(x = "Section Number", y = "Proportion") +
#   scale_color_manual(values = c("#BE0004", "#FEC409")) +
#   facet_wrap(~ dim) +
#   theme_bw() +
#   theme_kz() +
#   theme(panel.grid.minor = element_blank())
# 
# weightplotclean <- weightplot +
#   theme(legend.position = "none")

#SaveRectPlots(weightplot, weightplotclean, path = "~/Desktop/")
```


```{r}
#Dorsal and Ventral intersect at a vd_bin of 10.5
info %>% filter(tz_vdnona %in% c("Dorsal", "Ventral")) %>% mutate(vd_bins = round(2*vd_wavg)/2) %>% group_by(vd_bins, tz_vdnona) %>% count() %>% ggplot() + geom_line(aes(vd_bins, n, color = tz_vdnona))

#vd_bin 10.5 has a meanZolfr of 5.77 (5.28 and 5.93 on either side)
info %>% filter(tz_vdnona %in% c("Dorsal", "Ventral")) %>% mutate(vd_bins = round(2*vd_wavg)/2) %>% group_by(vd_bins) %>% summarise(meanZolfr = mean(Zolfr_Momb, na.rm=T)) %>% filter(between(vd_bins, 8, 12))

#tz vs zolfr by class
info %>% select(olfrname, class, oe_region:tz_vdnona, Zolfr_Momb) %>% drop_na() %>% mutate(zolfr_vd = ifelse(Zolfr_Momb >= 5.77, "Dorsal", "Ventral")) %>% group_by(class) %>% summarise(mintz = min(tz_val), meantz = mean(tz_val), maxtz = max(tz_val), minzo = min(Zolfr_Momb), meanzo = mean(Zolfr_Momb), maxzo = max(Zolfr_Momb))

#tan vs zolfr, colored by tzvd
info %>% ggplot() + geom_point(aes(tz_val, Zolfr_Momb, color = tz_vd))

#which ORs are discordant between Zolfr DV (vd_bin 10.5) and tan DV
info %>% select(olfrname, class, oe_region:tz_vdnona, Zolfr_Momb) %>% drop_na() %>% mutate(zolfr_vd = ifelse(Zolfr_Momb >= 5.77, "Dorsal", "Ventral")) %>% group_by(tz_vd, zolfr_vd) %>% filter(tz_vd != zolfr_vd)


DVinfo <- info %>% 
  select(olfrname:tz_vd, vd_wavg) %>%
  rowwise() %>%
  mutate(DVscore = sum(ifelse(oe_region == "Dorsal", 1, 0),
                       ifelse(tz_vd == "Dorsal", 2, 0), 
                       na.rm=T)) %>%
  ungroup() %>%
  mutate(DVdiscord1 = case_when(tan_zone == "unusual" ~ "Unusual",
                               DVscore >= 2 ~ "Dorsal",
                               DVscore == 0 ~ "Ventral",
                               DVscore == 1 ~ ifelse(vd_wavg < 10.5, 
                                                     "Ventral_vdmp", "Dorsal_vdmp")),
         DVdiscord2 = ifelse(is.na(DVdiscord1), 
                             case_when(is.na(tz_vd) ~ paste(oe_region, "oere", sep="-"),
                                       is.na(oe_region) ~ paste(tz_vd, "tzvd", sep="-")), 
                             DVdiscord1),
         DVdiscord = case_when(str_detect(DVdiscord2, "Dorsal") ~ "Dorsal",
                               str_detect(DVdiscord2, "Ventral") ~ "Ventral",
                               DVdiscord2 == "Unusual" ~ "Unusual"),
         DVcertainty = case_when(DVscore == 2 ~ "High",
                                 DVscore == 0 ~ "High",
                                 str_detect(DVdiscord2, "_vdmp") ~ "Medium",
                                 str_detect(DVdiscord2, "-") ~ "Low")) %>%
  select(olfrname, DVdiscord, DVcertainty, vd_wavg)

DVinfo %>% select(DVdiscord, vd_wavg) %>% filter(!is.na(DVdiscord)) %>% mutate(vd_rank = min_rank(vd_wavg)) %>% ggplot() + geom_jitter(aes(DVdiscord, vd_rank))
```


# Build model
Input: TPM (gene length and sequence depth normalized expression unit) for 1088 intact ORs across 269 samples across 6 Anterior-Posterior, 3 Medial-Lteral, and 3 Ventral-Dorsal 100um vibratome sliced single OBs.
```{r, eval=F}
tic()
voxalls <- blankdata

# pick prior and Monte Carlo Sample 
alpha <- matrix(0.65, N, D)
iter <- 100
pi_post <- SampleData(kzmY, alpha, iter) 

check <- ifelse(t(voxalls[,kzX$dim]) == kzX$slice, T, F)
weights <- ifelse(check, kzX$weight, 0)
weights <- miniclo(t(weights)) 
colnames(weights) <- rownames(kzmY) 

# We are going to use the ILR basis for computation
contrast.matrix <- create_default_ilr_base(D)
eta_post <- ilr_array(pi_post, contrast.matrix, 2)

# now calculate weighted composition
q_ilr <- array(0, dim=c(nrow(voxalls), D-1, iter))
for (i in 1:iter) q_ilr[,,i] <- weights %*% eta_post[,,i] #matrix multiplication operator

#clear RAM
remove(eta_post)
gc()

#proportional composition rather than in ILR, using driver 18-08-16 new ilrInv_array with transposed q_ilr and coord == 1
ilr_prop <- aperm(q_ilr, c(2,1,3))

remove(q_ilr)
gc() 
q_proportions <- ilrInv_array(ilr_prop, contrast.matrix, 1)

remove(ilr_prop)
gc()

q_proptidy <- aperm(q_proportions, c(3,2,1))
d <- dim(q_proptidy)
q_proptidy <- matrix(q_proptidy, d[1], prod(d[-1]))
quantiles <- c(0.025, .25, .5, .75, .975)
q_prop_quantiles <- t(kzcolQuant(q_proptidy, quantiles))
colnames(q_prop_quantiles) <- paste0("p", 100*quantiles)
voxel=rep(1:d[2], times=D)
coord.ap = voxalls[voxel, "AntPos"] 
coord.ml = voxalls[voxel, "MedLat"]
coord.vd = voxalls[voxel, "VenDor"]
tidy_result <- data.frame(voxel=rep(1:d[2], times=D), 
                          gene=rep(1:d[3], each=nrow(voxalls)), 
                          q_prop_quantiles) %>% 
  bind_cols(coord.ap, coord.ml, coord.vd)
toc()

remove(q_proptidy)
gc()

ranked <- tidy_result %>%
  arrange(gene) %>%
  mutate(olfrname = rep(colnames(kzmY), each=max(tidy_result$voxel))) %>%
  group_by(olfrname) %>%
  mutate(voxrankperOR = rank(desc(p50))) %>%
  ungroup() %>%
  group_by(voxel) %>%
  mutate(ORrankpervox = rank(desc(p50))) %>%
  ungroup() %>% group_by(gene) %>% 
  mutate(allVoxAvgp50 = mean(p50)) %>% 
  ungroup() %>% group_by(gene, AntPos) %>% 
  mutate(AP_Avgp50 = mean(p50), AP_SNR = p50/AP_Avgp50) %>%
  ungroup() %>% group_by(gene, MedLat) %>% 
  mutate(ML_Avgp50 = mean(p50), ML_SNR = p50/ML_Avgp50) %>% 
  ungroup() %>% group_by(gene, VenDor) %>% 
  mutate(VD_Avgp50 = mean(p50), VD_SNR = p50/VD_Avgp50) %>% 
  ungroup() %>% 
  mutate(voxSNRdim = (AP_SNR + ML_SNR + VD_SNR)/3) %>% 
  group_by(gene) %>% 
  mutate(geneRankSNR = rank(desc(voxSNRdim))) %>% 
  ungroup() %>% group_by(voxel) %>% 
  mutate(voxRankSNR = rank(desc(voxSNRdim))) %>% 
  ungroup() %>% 
  select(p2.5, p50, p97.5, AntPos:ORrankpervox, geneRankSNR, 
         voxRankSNR, AP_Avgp50:voxSNRdim, voxel)
```


# load save model output, no longer saving tidyresults
```{r, eval=F}
saveRDS(ranked, "~/Desktop/obmap/r_analysis/data/3dimOB/model/x_nodr3_dimweight.RDS")
```



# PredGlom setup
```{r}
ranked <- ranked %>% 
  rowwise() %>%
  mutate(symside = ifelse(MedLat >= symline$mlvals8[which(symline$apvals == AntPos)]-1, 
                          "Lateral", "Medial")) %>%
  ungroup()

#ranked %>% filter(olfrname == "Olfr1377") %>% group_by(symside) %>% count()
ranked %>% filter(olfrname == "Olfr1377") %>% ggplot() + geom_point(aes(AntPos, MedLat, color = symside))

ranked_Msym <- ranked %>% filter(symside == "Medial")
ranked_Lsym <- ranked %>% filter(symside == "Lateral")
ranked_MD <- ranked_Msym %>% filter(VenDor >= 11)
ranked_MV <- ranked_Msym %>% filter(VenDor < 11)
ranked_LD <- ranked_Lsym %>% filter(VenDor >= 11)
ranked_LV <- ranked_Lsym %>% filter(VenDor < 11)
ranked_unu <- ranked %>% filter(between(MedLat, 3, 13)) %>%
  filter(between(VenDor, 4, 12))

symline_rawM <- ranked_Msym %>% 
  group_by(AntPos)  %>%
  mutate(dist_2_symline = max(MedLat) - MedLat) %>%
  filter(dist_2_symline <= 1) %>% 
  ungroup()
symline_rawL <- ranked_Lsym %>% 
  group_by(AntPos) %>%
  mutate(dist_2_symline = MedLat - min(MedLat)) %>%
  filter(dist_2_symline <= 1) %>%
  ungroup()
ranked_symline <- bind_rows(symline_rawM, symline_rawL)

ranked_SD <- ranked_symline %>% filter(VenDor >= 11)
ranked_SV <- ranked_symline %>% filter(VenDor < 11)

nrow(ranked) == (nrow(ranked_MD) + nrow(ranked_MV) + nrow(ranked_LD) + nrow(ranked_LV))
```


```{r}
PredGloms("Olfr881", symconstrain = T, symline = T,  title = "Olfr881 - PredGloms50")
PredGloms("Olfr1377", symconstrain = T, symline = T,  title = "Olfr1377 - PredGloms50")
PredGloms("Olfr16", symconstrain = T, symline = T,  title = "Olfr16/MOR23 - PredGloms50")
PredGloms("Olfr17", symconstrain = T, symline = T,  title = "Olfr17/P2 - PredGloms50")
PredGloms("Olfr15", symconstrain = T, symline = T,  title = "Olfr15/MOR256-17 - PredGloms50")
PredGloms("Olfr160", symconstrain = T, symline = T,  title = "Olfr160/M72 - PredGloms50")
PredGloms("Olfr155", symconstrain = T,  title = "Olfr155/MOR37a - PredGloms50")
PredGloms("Olfr1507", symconstrain = T, symline = T,  title = "Olfr1507/MOR28 - PredGloms50")
```


# compare ORs in mombaerts paper

```{r}
fp1 <- PredGloms("Olfr881", symconstrain = T, symline = T,  out = "data")
fp2 <- PredGloms("Olfr1377", symconstrain = T, symline = T,  out = "data")
fp3 <- PredGloms("Olfr16", symconstrain = T, symline = T,  out = "data")
fp4 <- PredGloms("Olfr17", symconstrain = T, symline = T,  out = "data")
fp5 <- PredGloms("Olfr15", symconstrain = T, symline = F,  out = "data")
fp6 <- PredGloms("Olfr160", symconstrain = T, symline = T,  out = "data")
fp7 <- PredGloms("Olfr155", symconstrain = T,  out = "data")
fp8 <- PredGloms("Olfr1507", symconstrain = T, symline = T,  out = "data")

filter_preds <- bind_rows(fp1, fp2, fp3, fp4, fp5, fp6, fp7, fp8)
```


```{r}
allORs <- ranked %>% 
  select(olfrname) %>% 
  unique() %>% 
  filter(str_detect(olfrname, "Olfr")) %>% 
  pull(olfrname) 

allORs <- allORs[1:967]

doall <- PredList(allORs, verboseTF = T, out = "data")
```


```{r}
#did 210321 pick on a voxV3 model, may need to repick or check that all coordinates exist in voxV4B
mom_pick <- read_csv("~/Desktop/obmap/r_analysis/data/3dimOB/analysis/Mombcomp_picalign_coords.csv") %>% filter(model == 210321)

# Do two integer sequences (given max and min of sequences) intersect?
Overlap <- function(a, b, c, d) {
  set1 <- a:b
  set2 <- c:d
  if (length(intersect(set1, set2)) > 0) {
    return(T)
  } else if (length(intersect(set1, set2)) == 0) {
    return(F)
  } else {
    return(NA)
  } #endif
} #end Overlap

#as matrix
mom_names <- c("olfrname", "side", 
               "bestAP.pred", "bestAP.pick", 
               "bestAPdist",
               "minAP.pred", "maxAP.pred", 
               "minAP.pick", "maxAP.pick", 
               "btwnAP.point", "ovlpAP.clust",
               "meanAP.pred", "meanAP.pick",
               "bestVD.pred", "bestVD.pick", 
               "bestVDdist",
               "minVD.pred", "maxVD.pred", 
               "minVD.pick", "maxVD.pick", 
               "btwnVD.point", "ovlpVD.clust",
               "meanVD.pred", "meanVD.pick",
               "bestML.pred", "bestML.pick", 
               "bestMLdist",
               "minML.pred", "maxML.pred", 
               "minML.pick", "maxML.pick", 
               "btwnML.point", "ovlpML.clust", 
               "meanML.pred", "meanML.pick",
               "sum_dist", "dist_3d",
               "min_p2p", "mean_p2p", "max_p2p")
mom_mtx <- matrix(nrow = nrow(mom_pick), ncol = length(mom_names))

#between is pred.best between pick.min, pick.max
#overlap is pred.min, pred.max overlaps with pick.min, pick.max
for (i in 1:nrow(mom_pick)) {
  mom_clust <- filter_preds %>%
    filter(olfrname == mom_pick$olfrname[i]) %>%
    filter(str_detect(side, mom_pick$side[i]))
  mom_point <- mom_clust %>%
    filter(clustmaxp == p50)
  best_pick <- c(mom_pick$bestAP[i], mom_pick$bestVD[i], mom_pick$bestML[i])
  
  pick_grid <- expand.grid(mom_pick$minAP[i]:mom_pick$maxAP[i], 
                           mom_pick$minML[i]:mom_pick$maxML[i],
                           mom_pick$minVD[i]:mom_pick$maxVD[i])
  colnames(pick_grid) <- c("AntPos", "MedLat", "VenDor")
  pg2 <- pick_grid %>% 
    as_tibble() %>%
    mutate(batname = paste(AntPos, MedLat, VenDor, sep = "-")) %>% 
    filter(batname %in% blankdata$catname)
  raffe <- NA
  for (j in 1:nrow(mom_clust)) {
    for (k in 1:nrow(pg2)) {
      raffe <- c(raffe, Dist3d(mom_clust, pg2, j, k))
    } #endfork
  } #endforj
  
  if (nrow(mom_point > 0)) {
    mom_vec <- c(mom_pick$olfrname[i], 
                 mom_pick$side[i], 
                 mom_point$AntPos, best_pick[1], 
                 abs(mom_point$AntPos - best_pick[1]),
                 min(mom_clust$AntPos), max(mom_clust$AntPos), 
                 mom_pick$minAP[i], mom_pick$maxAP[i],
                 between(mom_point$AntPos, mom_pick$minAP[i], mom_pick$maxAP[i]),
                 Overlap(mom_pick$minAP[i], mom_pick$maxAP[i], 
                         min(mom_clust$AntPos), max(mom_clust$AntPos)), 
                 mean(mom_clust$AntPos), mean(mom_pick$minAP[i], mom_pick$maxAP[i]),
                 mom_point$VenDor, best_pick[2], 
                 abs(mom_point$VenDor - best_pick[2]),
                 min(mom_clust$VenDor), max(mom_clust$VenDor),
                 mom_pick$minVD[i], mom_pick$maxVD[i],
                 between(mom_point$VenDor, mom_pick$minVD[i], mom_pick$maxVD[i]),
                 Overlap(mom_pick$minVD[i], mom_pick$maxVD[i], 
                         min(mom_clust$VenDor), max(mom_clust$VenDor)), 
                 mean(mom_clust$VenDor), mean(mom_pick$minVD[i], mom_pick$maxVD[i]),
                 mom_point$MedLat, best_pick[3],
                 abs(mom_point$MedLat - best_pick[3]),
                 min(mom_clust$MedLat), max(mom_clust$MedLat),
                 mom_pick$minML[i], mom_pick$maxML[i],
                 between(mom_point$MedLat, mom_pick$minML[i], mom_pick$maxML[i]),
                 Overlap(mom_pick$minML[i], mom_pick$maxML[i], 
                         min(mom_clust$MedLat), max(mom_clust$MedLat)),
                 mean(mom_clust$MedLat), mean(mom_pick$minML[i], mom_pick$maxML[i]),
                 sum(abs(mom_point$AntPos - best_pick[1]),
                     abs(mom_point$VenDor - best_pick[2]),
                     abs(mom_point$MedLat - best_pick[3])),
                 sqrt((mom_point$AntPos - best_pick[1])^2 +
                  (mom_point$MedLat - best_pick[2])^2 + 
                  (mom_point$VenDor - best_pick[3])^2),
                 min(raffe, na.rm = T),
                 mean(raffe, na.rm = T),
                 max(raffe, na.rm=T))
  } else {
    mom_vec <- c(mom_pick$olfrname[i], mom_pick$side[i], rep(NA, length(mom_names)-2))
  } #endif
  mom_mtx[i,] <- mom_vec
} #endfori
colnames(mom_mtx) <- mom_names

mom_tib <- as_tibble(mom_mtx) %>% unique() 
mom_tib$bestAP.pred %<>% as.numeric
mom_tib$bestAP.pick %<>% as.numeric
mom_tib$bestAPdist %<>% as.numeric
mom_tib$minAP.pred %<>% as.numeric
mom_tib$maxAP.pred %<>% as.numeric
mom_tib$minAP.pick %<>% as.numeric
mom_tib$maxAP.pick %<>% as.numeric
mom_tib$btwnAP.point %<>% as.logical
mom_tib$ovlpAP.clust %<>% as.logical
mom_tib$meanAP.pred %<>% as.numeric
mom_tib$meanAP.pick %<>% as.numeric
mom_tib$bestVD.pred %<>% as.numeric
mom_tib$bestVD.pick %<>% as.numeric
mom_tib$bestVDdist %<>% as.numeric
mom_tib$minVD.pred %<>% as.numeric
mom_tib$maxVD.pred %<>% as.numeric
mom_tib$minVD.pick %<>% as.numeric
mom_tib$maxVD.pick %<>% as.numeric
mom_tib$btwnVD.point %<>% as.logical
mom_tib$ovlpVD.clust %<>% as.logical
mom_tib$meanVD.pred %<>% as.numeric
mom_tib$meanVD.pick %<>% as.numeric
mom_tib$bestML.pred %<>% as.numeric
mom_tib$bestML.pick %<>% as.numeric
mom_tib$bestMLdist %<>% as.numeric
mom_tib$minML.pred %<>% as.numeric
mom_tib$maxML.pred %<>% as.numeric
mom_tib$minML.pick %<>% as.numeric
mom_tib$maxML.pick %<>% as.numeric
mom_tib$btwnML.point %<>% as.logical
mom_tib$ovlpML.clust %<>% as.logical
mom_tib$meanML.pred %<>% as.numeric
mom_tib$meanML.pick %<>% as.numeric
mom_tib$sum_dist %<>% as.numeric
mom_tib$dist_3d %<>% as.numeric
mom_tib$min_p2p %<>% as.numeric
mom_tib$mean_p2p %<>% as.numeric
mom_tib$max_p2p %<>% as.numeric

mom_score <- mom_tib %>%
  rowwise() %>%
  mutate(mean_dist = sum(abs(meanAP.pred - meanAP.pick), 
                         abs(meanVD.pred - meanVD.pick),
                         abs(meanML.pred - meanML.pick))) %>%
  ungroup() %>%
  mutate(btwn_score = btwnAP.point + btwnVD.point + btwnML.point,
         ovlp_score = ovlpAP.clust + ovlpVD.clust + ovlpML.clust,
         which_btwn = paste(ifelse(btwnAP.point == T, "AP", "X"),
                            ifelse(btwnVD.point == T, "VD", "X"),
                            ifelse(btwnML.point == T, "ML", "X"), sep = "-"),
         which_ovlp =paste(ifelse(ovlpAP.clust == T, "AP", "X"),
                           ifelse(ovlpVD.clust == T, "VD", "X"),
                           ifelse(ovlpML.clust == T, "ML", "X"), sep = "-")) %>%
  select(olfrname, side, btwn_score:which_ovlp, sum_dist, mean_dist, everything()) %>%
  filter(!is.na(minAP.pred)) %>%
  arrange(desc(ovlp_score))

cat("Between Score Total:", sum(mom_score$btwn_score), "\n",
    "Overlap Score Total:", sum(mom_score$ovlp_score), "\n",
    "Sum of Distances:", sum(mom_score$sum_dist), "\n",
    "Mean of Distances:", mean(mom_score$sum_dist))
#c | between=11, overlap=16, tdist=147.5, mdist=12.292
#d | between=12, overlap=14, tdist=155.5, mdist=12.958
#d2 | between=12, overlap=15, tdist=157.5, mdist=13.125
#210404_vox4B_dtvt_OConly no Olfr160 | 20,22,128,10.67
#210518 21,24,83,7.55

#look at the whole dataset
mom_score %>%
  gather(key = "dim", value = "distance", bestAPdist, bestMLdist, bestVDdist) %>%
  select(dim, distance) %>%
  group_by(dim) %>%
  mutate(meandist = mean(distance),
         mediandist = median(distance),
         stdevdist = sd(distance),
         meanUPsd = meandist + stdevdist,
         meanDOWNsd = meandist - stdevdist) %>%
  ggplot(aes(distance)) + 
  geom_dotplot() + 
  geom_density() + 
  geom_vline(aes(xintercept = meandist, color = "Mean"), size = 2) +
  geom_vline(aes(xintercept = mediandist, color = "Median")) +
  geom_vline(aes(xintercept = meanUPsd, color = "Mean+SD")) +
  geom_vline(aes(xintercept = meanDOWNsd, color = "Mean-SD")) +
  facet_wrap(~ dim, nrow = 3, ncol = 1) + 
  theme(legend.position = "bottom") +
  ggtitle("DorsalML best predictions VS Momb5OR picked positions", subtitle = "New model - Vox4B, Olfr160 removed")


#look at each glom
Compare_momb_pickpred <- function(mom_dat) {
  mom_plots <- vector(mode = "list", length = nrow(mom_dat))
  for (i in 1:nrow(mom_dat)) {
    mom_vis <- mom_dat %>% 
      filter(olfrname == mom_dat$olfrname[i]) %>% 
      filter(side == mom_dat$side[i]) %>% 
      select(olfrname, side, bestAP.pred:maxAP.pick, 
             bestML.pred:maxML.pick, bestVD.pred:maxVD.pick) %>% 
      select(-bestAPdist, -bestMLdist, -bestVDdist) %>% 
      pivot_longer(cols = c(contains(".pred"), contains(".pick")),
                   names_to = "pick_or_pred",
                   values_to = "value") %>%
      mutate(pick.pred = ifelse(str_detect(pick_or_pred, "pick"), 
                                "Picked", ifelse(str_detect(pick_or_pred, "pred"), 
                                                 "Predicted", NA))) %>%
      mutate(dim = ifelse(str_detect(pick_or_pred, "AP"), 
                          "AntPos", ifelse(str_detect(pick_or_pred, "ML"), 
                                           "MedLat", ifelse(str_detect(pick_or_pred, "VD"), 
                                                            "VenDor", NA)))) %>% 
      mutate(min.max = ifelse(str_detect(pick_or_pred, "max"), 
                              "Max", ifelse(str_detect(pick_or_pred, "min"), 
                                            "Min", "Best"))) %>% 
      select(-pick_or_pred) %>% 
      pivot_wider(names_from = min.max, values_from = value)
    
    mom_tit <- paste(mom_dat$olfrname[i], mom_dat$side[i])
    mom_subtit <- paste("Distance: ", mom_dat$sum_dist[i],
                        "  Between Score:", mom_dat$btwn_score[i], mom_dat$which_btwn[i],
                        "  Overlap Score:", mom_dat$ovlp_score[i], mom_dat$which_ovlp[i])
    
    mom_plots[[i]] <- ggplot(mom_vis) + 
      geom_pointrange(aes(x=dim, y=Best, color=pick.pred, 
                          ymin=Min, ymax=Max, group=pick.pred), 
                      position=position_dodge(width = 0.25)) +
      ggtitle(mom_tit, subtitle = mom_subtit) +
      xlab("Position") +
      ylab("Dimension") +
      theme(legend.position = "bottom")
  } #endfori
  if (i == nrow(mom_dat)) {
    return(mom_plots)
  } #endif
} #end func

momcomp_plots <- Compare_momb_pickpred(mom_score)
momcomp_plots[[1]]

CheckMC <- function(olfr, xside) {
  mom_clust <- filter_preds %>%
    filter(olfrname == olfr) %>%
    filter(str_detect(side, xside))
  mom_click <- mom_pick %>%
    filter(olfrname == olfr) %>%
    filter(str_detect(side, xside))
  
  click_grid <- expand.grid(mom_click$minAP[1]:mom_click$maxAP[1], 
                           mom_click$minML[1]:mom_click$maxML[1],
                           mom_click$minVD[1]:mom_click$maxVD[1])
  colnames(click_grid) <- c("AntPos", "MedLat", "VenDor")
  pg2 <- click_grid %>% 
    as_tibble() %>%
    mutate(batname = paste(AntPos, MedLat, VenDor, sep = "-")) %>% 
    filter(batname %in% blankdata$catname)
  
  p <- plot_ly(type = "scatter3d", mode = "markers") %>%
      add_trace(data=blankdata, x=~AntPos, y=~MedLat, z=~VenDor,
                color="shell", opacity=0.1,
                marker = list(size = 5, color = "grey")) %>%
      add_trace(data=mom_clust, x=~AntPos, y=~MedLat, z=~VenDor, 
                color="Prediction",
                marker = list(size = 6, color = "red", 
                              line = list(color = 'black', width = 0.5))) %>%
      add_trace(data=pg2, x=~AntPos, y=~MedLat, z=~VenDor, 
                color="Picked",  opacity=0.6,
                marker = list(size = 6, color = "orange", 
                              line = list(color = 'black', width = 0.5))) %>%
      layout(title = title,
             scene = list(xaxis = list(title = 'Anterior-Posterior'),
                          yaxis = list(title = 'Medial-Lateral'),
                          zaxis = list(title = 'Ventral-Dorsal')))
  return(p)
}  


ggplot(mom_score, aes(side, min_p2p * 100, label = olfrname)) + 
  geom_jitter(width = 0.1, height = 0) + 
  geom_text_repel() + labs(x = "OB Side", y ="3D distance (um)")


ggplot(mom_score, aes(side, min_p2p * 100)) + 
  geom_jitter(width = 0.1, height = 0) +  labs(x = "OB Side", y ="3D distance (um)")


ggplot(mom_score, aes(side, min_p2p * 100)) + 
  geom_boxplot()

CheckMC("Olfr881", "Lat")

#given a mompick glom, check its DVU zone, compare its distance to X many random ORs from the same DVU zone and OB side, output individual distances or mean distances per mompick
RandomMC <- function(input_preds, randX) {
  randmtx <- matrix(nrow = randX*nrow(mom_pick), ncol = 7)
  mtxcounter <- 1
  for (i in 1:nrow(mom_pick)) {
    dvuX <- DVinfo %>% filter(olfrname == mom_pick$olfrname[i]) %>% pull(DVdiscord)
    
    viable <- input_preds %>% 
      filter(pgStatus == dvuX) %>% 
      filter(side == mom_pick$side[i]) %>% 
      filter(olfrname != mom_pick$olfrname[i])
    rlist <- viable %>% 
      select(olfrname) %>% 
      unique() %>% 
      pull(olfrname)
    
    if (dvuX == "Unusual") {
      samlist <- sample(rlist, 15)
    } else {
      samlist <- sample(rlist, randX)
    } #endif
    
    pick_grid <- expand.grid(mom_pick$minAP[i]:mom_pick$maxAP[i], 
                             mom_pick$minML[i]:mom_pick$maxML[i],
                             mom_pick$minVD[i]:mom_pick$maxVD[i])
    colnames(pick_grid) <- c("AntPos", "MedLat", "VenDor")
    pg2 <- pick_grid %>% 
      as_tibble() %>%
      mutate(batname = paste(AntPos, MedLat, VenDor, sep = "-")) %>% 
      filter(batname %in% blankdata$catname)
    for (q in 1:length(samlist)) {
      sam_clust <- input_preds %>% 
        filter(olfrname == samlist[q]) %>%
        filter(side == mom_pick$side[i])
      raffe <- NA
      for (r in 1:nrow(sam_clust)) {
        for (s in 1:nrow(pg2)) {
          raffe <- c(raffe, Dist3d(sam_clust, pg2, r, s))
        } #endforr
      } #endfors
      min_r2p <- min(raffe, na.rm=T)
      mean_r2p <- mean(raffe, na.rm=T)
      max_r2p <- max(raffe, na.rm=T)
      
      randvec <- c(mom_pick$olfrname[i], mom_pick$side[i], 
                   sam_clust$olfrname[1], sam_clust$side[1],
                   min_r2p, mean_r2p, max_r2p)
      randmtx[mtxcounter,] <- randvec 
      mtxcounter <- mtxcounter + 1
    } #endforq
  } #endfori
  colnames(randmtx) <- c("olfrnamePick", "sidePick", "olfrnameRand", "sideRand",
                         "min_r2p", "mean_r2p", "max_r2p")
  randtb <- as_tibble(randmtx) %>% drop_na()
  randtb$min_r2p %<>% as.numeric
  randtb$mean_r2p %<>% as.numeric
  randtb$max_r2p %<>% as.numeric
  return(randtb)
} #end RandomMC

real <- mom_score %>% select(olfrname, side, min_p2p)
randtest <- RandomMC(doall, 100)
rand1 <- randtest %>% 
  group_by(olfrnamePick, sidePick) %>%
  summarise(min_p2p = mean(min_r2p)) %>%
  rename(olfrname = olfrnamePick,
         side = sidePick) %>%
  left_join(real, by = c("olfrname", "side")) %>%
  pivot_longer(names_to = "from", values_to = "distance",
               cols = c(min_p2p.x, min_p2p.y)) %>%
  mutate(refrom = ifelse(str_detect(from, "x"), "Random", "Predicted"))

randvactual_legend <- ggplot(rand1, aes(side, distance, color = refrom)) + 
  geom_boxplot() +
  geom_point(position = position_dodge(width = 0.75)) +
  scale_color_manual(values = c("#ff0000","#010000")) +
  labs(x = "Glomerulus Zone", y = "Distance (100m Voxels)") +
  theme_bw() +
  theme_kz()

randvactual <- randvactual_legend + theme(legend.position = "none")  
```


```{r}
allORs <- ranked %>% select(olfrname) %>% unique() %>% pull(olfrname)
dontdoORs <- c("Olfr3_3_18", "Taar6", "Taar2", "Taar5", "Taar4",)
allORsGood <- allORs[-which(allORs %in% dontdoORs)]

pgall <- PredList(allORsGood[1:967], topByN = 10, symconstrainTF = T, verboseTF = F, out = "data")

saveRDS(pgall, "~/Desktop/obmap/r_analysis/data/3dimOB/model/210501_pgSC_hmORsnotaars__omprepweights.RDS")
```



```{r}
PUBG("Olfr881", face = "Dorsal", color_best = "blue", color_notbest = "#51B5C7")
PUBG("Olfr1377", face = "Dorsal", color_best = "green", color_notbest = "#64AD35")
PUBG("Olfr16", face = "Dorsal", color_best = "#AA262A", color_notbest = "#7DFB2B")
PUBG("Olfr160", face = "Dorsal", color_best = "#68B697", color_notbest = "#821268")
PUBG("Olfr17", face = "Dorsal", color_best = "#E4D251", color_notbest = "#BA0524")
PUBG("Olfr155", face = "Dorsal", color_best = "#A2EDC5", color_notbest = "#4383BF")
PUBG("Olfr1507", face = "Dorsal", color_best = "#9E0073", color_notbest = "#8600A8")
PUBG("Olfr15", face = "Dorsal", color_best = "#E9F059", color_notbest = "#699D34")
```

# feature plots
```{r}
pgfeat <- pgall %>% left_join(info, by = "olfrname") %>% filter(p50 == clustmaxp) %>%
  mutate(Class = as_factor(class))

p <- plot_ly(type = "scatter3d", mode = "markers") %>%
  add_trace(data=blankdata, x=~AntPos, y=~MedLat, z=~VenDor,
            color="shell", opacity=0.2,
            marker = list(size = 5, color = "grey")) %>%
  add_trace(data=pgfeat, 
            x=~AntPos, y=~MedLat, z=~VenDor, color = ~olfrname,
            opacity=0.6,
            marker = list(size = 6, 
                          line = list(color = 'black', width = 0.5))) %>%
  layout(scene = list(xaxis = list(visible = F),
                      yaxis = list(visible = F),
                      zaxis = list(visible = F)))
p


agdat <- readRDS("~/Desktop/obmap/r_analysis/data/3dimOB/model/210430_ad50_hmORs_omprepweights.RDS") %>% filter(p50 == clustmaxp) %>% mutate(Class = as_factor(class)) %>% filter(!is.na(class))

a <- plot_ly(type = "scatter3d", mode = "markers") %>%
  add_trace(data=blankdata, x=~AntPos, y=~MedLat, z=~VenDor,
            color="shell", opacity=0.2,
            marker = list(size = 5, color = "grey")) %>%
  add_trace(data=agdat, 
            x=~AntPos, y=~MedLat, z=~VenDor, color = ~Class,
            opacity=0.6,
            marker = list(size = 6, 
                          line = list(color = 'black', width = 0.5))) %>%
  layout(scene = list(xaxis = list(visible = F),
                      yaxis = list(visible = F),
                      zaxis = list(visible = F)))
a

pgviodat <- pgall %>%
  group_by(olfrname) %>%
  summarise(meanAP = mean(AntPos),
            meanVD = mean(VenDor),
            meanML = mean(MedLat)) %>%
  mutate(sortrank = min_rank(meanVD)) %>%
  rename(gene = olfrname) %>%
  add_row(gene = "Taar4", meanAP = 12, meanVD = 22, meanML = 14, sortrank = 95)
```

