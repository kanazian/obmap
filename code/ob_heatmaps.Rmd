---
title: "OB heatmaps"
author: "kanazian"
date: "`r Sys.Date()`"
output: github_document
always_allow_html: true
---

# Goal:

Heatmaps of OR gene expression across single dimension positions annotated with features, examination of gene covariance and calculation of glomerulus symmetry

# Setup

Load packages and functions

```{r setup, message=F, warning=F}
#knitr::opts_chunk$set(warning=F)
#packages
library(heatmaply)
library(reshape2)
library(gtools)
library(patchwork)
library(plotly)
library(tidyverse)
library(cowplot)
library(uwot)
library(magrittr)

#functions
#x is a vector of tpm values for an OR across samples
NormalizeMaxMin <- function(x) {
    if (max(x) == 0) {
        return(x)
    } else {
        #x needs to be pseudocounted
        (x-min(x))/(max(x)-min(x))
    }
} #end NormalizeMaxMin

GeoMean <- function(x, na.rm=TRUE) {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
} #end GeoMean

#Apply totalTPM normalization factors
GetTotaltpmWeights <- function(repn, dimc = NA) {
    if (is.na(dimc)) {
        pull_rep <- totaltpm_norms %>% filter(rep == repn) %>% arrange(slice) %>% pull(rep_norms)
        return(pull_rep)
    } else {
        pull_dim <- totaltpm_norms %>% filter(dim == dimc) %>% filter(rep == repn) %>% pull(dim_norms)
        return(pull_dim)
    } #endif
} #end GetTotaltpmWeights

#given raw TPM data, normalize values to between 0 and 1 (inclusive)
NormTPM <- function(df_tpm) {
    x_vals <- df_tpm %>% select(-slice) %>% t()
    x_vals <- x_vals# + 0.25
    
    x_norm <- matrix(nrow = nrow(x_vals), ncol = ncol(x_vals))
    for (i in 1:nrow(x_vals)) {
        if (min(x_vals[i,]) - max(x_vals[i,]) == 0) {
            x_norm[i,] <- rep(0, length(x_vals[i,]))
        } else {
            x_norm[i,] <- NormalizeMaxMin(x_vals[i,])
        } #endif
    } #endfor
    
    colnames(x_norm) <- df_tpm$slice
    rownames(x_norm) <- rownames(x_vals)
    return(x_norm)
} # end NormTPM

NormByVector <- function(df_tpm, vector) {
    soi <- df_tpm %>% select(-slice) %>% t()
    #soi <- soi + 0.25
    for (i in 1:ncol(soi)) {
        soi[,i] <- soi[,i] / vector[i]
    } #endfor
    soi_norm <- matrix(nrow = nrow(soi), ncol = ncol(soi))
    for (i in 1:nrow(soi)) {
        soi_norm[i,] <- NormalizeMaxMin(soi[i,])
    } #endfor
    colnames(soi_norm) <- df_tpm$slice
    rownames(soi_norm) <- rownames(soi)
    return(soi_norm)
} #end NormByVector

#... are a set of identical dimension DFs
normNormDF <- function(..., calc = "mean", median4 = "use4") {
    args <- list(...)
    
    if (calc == "mean") {
        if (length(args) == 4) {
            df_merge <- matrix(nrow = nrow(args[[1]]), ncol = ncol(args[[1]]))
            for (i in 1:ncol(args[[1]])) {
                df_merge[,i] <- args[[1]][,i] + args[[2]][,i] + args[[3]][,i] + args[[4]][,i]
            } #endfor
        } else if (length(args) == 3) {
            df_merge <- matrix(nrow = nrow(args[[1]]), ncol = ncol(args[[1]]))
            for (i in 1:ncol(args[[1]])) {
                df_merge[,i] <- args[[1]][,i] + args[[2]][,i] + args[[3]][,i]
            } #endfor
        } else {
            print("This function is poorly written, can only take input of 3 or 4 DFs")
        } #endif
        
    } else if (calc == "median") {
        if (length(args) == 5) {
            df_merge <- matrix(nrow = nrow(args[[1]]), ncol = ncol(args[[1]]))
            for (i in 1:ncol(args[[1]])) {
                for (j in 1:nrow(args[[1]])) {
                    df_merge[j,i] <- median(c(args[[1]][j,i], args[[2]][j,i],
                                              args[[3]][j,i], args[[4]][j,i],
                                              args[[5]][j,i]))
                } #endforj
            } #endfori
        } else if (length(args) == 4) {
            if (median4 == "use4") {
                df_merge <- matrix(nrow = nrow(args[[1]]), ncol = ncol(args[[1]]))
                for (i in 1:ncol(args[[1]])) {
                    for (j in 1:nrow(args[[1]])) {
                        # add a 0 val in order to avoid even numbered median being mean of 3rd and 4th value
                        df_merge[j,i] <- median(c(args[[1]][j,i], args[[2]][j,i],
                                                  args[[3]][j,i], args[[4]][j,i]))
                    } #endforj
                } #endfori
            } else if (median4 == "add0") {
                df_merge <- matrix(nrow = nrow(args[[1]]), ncol = ncol(args[[1]]))
                for (i in 1:ncol(args[[1]])) {
                    for (j in 1:nrow(args[[1]])) {
                        # add a 0 val in order to avoid even numbered median being mean of 3rd and 4th value
                        df_merge[j,i] <- median(c(0, args[[1]][j,i], args[[2]][j,i],
                                                  args[[3]][j,i], args[[4]][j,i]))
                    } #endforj
                } #endfori
            }else if (median4 == "addmean") {
                df_merge <- matrix(nrow = nrow(args[[1]]), ncol = ncol(args[[1]]))
                for (i in 1:ncol(args[[1]])) {
                    for (j in 1:nrow(args[[1]])) {
                        # add a 0 val in order to avoid even numbered median being mean of 3rd and 4th value
                        df_merge[j,i] <- median(c(args[[1]][j,i], args[[2]][j,i],
                                                  args[[3]][j,i], args[[4]][j,i],
                                                  mean(c(args[[1]][j,i], 
                                                         args[[2]][j,i],
                                                         args[[3]][j,i], 
                                                         args[[4]][j,i]))))
                    } #endforj
                } #endfori
            } #endif median4
        } else if (length(args) == 3) {
            df_merge <- matrix(nrow = nrow(args[[1]]), ncol = ncol(args[[1]]))
            for (i in 1:ncol(args[[1]])) {
                for (j in 1:nrow(args[[1]])) {
                    df_merge[j,i] <- median(c(args[[1]][j,i], args[[2]][j,i], 
                                              args[[3]][j,i]))
                } #endforj
            } #endfori
        } else {
            print("This function is poorly written, can only take input of 3 or 4 DFs")
        } #endif length
    } #endif cal
    
    #normalize merged normalized values
    merge_vals <- df_merge
    merge_norm <- matrix(nrow = nrow(merge_vals), ncol = ncol(merge_vals))
    for (i in 1:nrow(merge_vals)) {
        merge_norm[i,] <- NormalizeMaxMin(merge_vals[i,])
    } #endfor
    
    #name rows and columns
    colnames(merge_norm) <- colnames(args[[1]])
    rownames(merge_norm) <- rownames(args[[1]])
    return(merge_norm)
} #end normNormDF

#given a set of normalized values, merge them into 1 df, renormalize, sort, return sortlist
MakeSort <- function(..., method = "posmean") {
    args <- list(...)
    
    if (length(args) == 4) {
        merge_norm <- normNormDF(args[[1]], args[[2]], args[[3]], args[[4]])
    } else if (length(args) == 3) {
        merge_norm <- normNormDF(args[[1]], args[[2]], args[[3]])
    } else {
        print("This function is poorly written, can only take input of 3 or 4 DFs")
    }#endif
    
    merge_bin <- merge_norm
    ornames <- rownames(args[[1]])
    
    if (method == "kzsort") {
        #sort based on position of maximum expression section and 
        #distance to the mean of positions for the three highest expression sections
        #higher distances being placed further away, no management for ties.
        #create a maxsec variable
        #anything lower than 1 becomes 0
        merge_bin[merge_bin < 1] <- 0
        maxsec <- vector(mode = "numeric", length = nrow(merge_bin))
        for (i in 1:nrow(merge_bin)) {
            for (s in 1:ncol(merge_bin)) {
                if (merge_bin[i,s] == 1) {
                    maxsec[i] <- s
                } #endif
            } #endfor
        } #endfor
        
        #find avg position of top 3 sections
        avgpos3 <- vector(mode = "numeric", length = nrow(merge_bin))
        for (i in 1:nrow(merge_bin)) {
            avgpos3[i] <- mean(which(min_rank(desc(merge_norm[i,])) <= 3))
        } #endfor
        
        max2avg <- vector(mode = "numeric", length = nrow(merge_bin))
        for (i in 1:length(maxsec)) {
            max2avg[i] <- abs(maxsec[i] - avgpos3[i])
        } #endfor
        
        sorttable <- tibble(gene = ornames, maxsec, avgpos3, max2avg) %>% 
            arrange(desc(maxsec, max2avg)) %>% 
            mutate(sortrank = 1:length(ornames))
        
    } else if (method == "posmean") {
        #weighted avg based on python code for "find_1_glom"
        #weighted_avg = sum(x*y for x,y in zip(indexes,vals))/sum(vals) 
        #zip(c(1,2,3), c("a","b","c")) = (1,"a"), (2,"b"), (3,"c")
        secs <- c(1:23)
        wavgs <- vector(mode = "numeric", length = nrow(merge_bin))
        for (i in 1:nrow(merge_norm)) {
            vals <- merge_norm[i,]
            sumvals <- sum(vals)
            prods <- vector(mode = "numeric", length = length(vals))
            for (s in 1:length(vals)) {
                prods[s] <- vals[s] * secs[s]
            }
            wavgs[i] <- sum(prods)/sumvals
        }
        
        sorttable <- tibble(gene = ornames, wavgs) %>%
            arrange(desc(wavgs)) %>%
            mutate(sortrank = 1:length(ornames))
        
    } else if (method == "123") {
        #which secs are ranked 1,2,3
        onesec <- vector(mode = "numeric", length = nrow(merge_norm))
        for (i in 1:nrow(merge_norm)) {
            onesec[i] <- which(min_rank(desc(merge_norm[i,])) == 2)
        } #endfor
        twosec <- vector(mode = "numeric", length = nrow(merge_norm))
        for (i in 1:nrow(merge_norm)) {
            twosec[i] <- which(min_rank(desc(merge_norm[i,])) == 2)
        } #endfor
        threesec <- vector(mode = "numeric", length = nrow(merge_norm))
        for (i in 1:nrow(merge_norm)) {
            threesec[i] <- which(min_rank(desc(merge_norm[i,])) == 3)
        } #endfor
        
        sorttable <- tibble(gene = ornames, onesec, twosec, threesec) %>%
            arrange(desc(onesec, twosec, threesec)) %>%
            mutate(sortrank = 1:length(ornames))
    } #endif
    return(sorttable)
} #end MakeSort

#given normalized data and a list with "gene" and "sortrank" column, sort the normalized data
#list must have ORs in "gene" column and rank in "sortrank" column
SortByList <- function(df_norm, list) {
    df_tib <- as_tibble(df_norm)
    df_tib$gene <- rownames(df_norm)
    df_info <- left_join(df_tib, list, by = "gene") %>% arrange(sortrank)
    df_matrix <- t(t(df_info %>% select(-gene, -sortrank, -wavgs)))
    rownames(df_matrix) <- df_info$gene
    return(df_matrix)
} #end SortByList

#given a normalized matrix, output old style Black(0) to Red(1) heatmaps
MakeBlackRedHeatmap <- function(df_norm, title = NA) {
    df_df <- as.data.frame(df_norm)
    df_df$target = rownames(df_df)
    df_melt <- melt(df_df, id.vars ="target")
    names(df_melt)[2:3] <- c("section","normTPM")
    #make genelist into character vector
    df_melt$target <- as.character(df_melt$target)
    df_melt$target <- factor(df_melt$target, levels=unique(df_melt$target))
    
    plot <- ggplot(df_melt, aes(section, target)) +
        geom_tile(aes(fill = normTPM), color = "grey") +
        scale_fill_gradient2(low = "black", mid = "red", high = "red3", midpoint = 0.65) +
        ylab("Olfr Genes") +
        theme(legend.title = element_text(size = 11, vjust = 1),
              legend.text = element_text(size = 7),
              legend.position = "none", #none if you dont want expression level legend
              plot.title = element_text(size = 24),
              axis.title.x = element_text(size = 0, vjust = 50, face="bold"),
              axis.title.y = element_text(size = 0, vjust = 0, face="bold"),
              axis.text.x = element_text(angle = 330, hjust = 0, vjust = 2, size = 0),
              axis.text.y = element_text(size = 0),
              axis.ticks = element_blank()) +
        labs(fill = "Expression Level")
    
    if (is.na(title)) {
        return(plot)
    } else {
        plot <- plot + ggtitle(title)
        return(plot)
    }#endif
} #end MakeBlackRedHeatmap

#given a single weighting vector, transform input tpm_dfs into heatmaps
ProcessHeatmaps <- function(..., weights, out = "heatmaps") {
    args <- list(...)
    
    presort <- vector(mode = "list", length = length(args))
    for (i in 1:length(args)) {
        presort[[i]] <- NormByVector(args[[i]], weights)
    } #endfor
    
    sort <- do.call(MakeSort, presort)
    
    aftersort <- vector(mode = "list", length = length(presort))
    for (i in 1:length(presort)) {
        aftersort[[i]] <- SortByList(presort[[i]], sort)
    } #endfor
    
    heatmaps <- vector(mode = "list", length = length(aftersort))
    for (i in 1:length(aftersort)) {
        heatmaps[[i]] <- MakeBlackRedHeatmap(aftersort[[i]])
    } #endfor
    
    if (str_detect(tolower(out), "sortlist")) {
        return(sort)
    } else if (str_detect(tolower(out), "sorted")) {
        return(aftersort)
    } else if (str_detect(tolower(out), "normalized")) {
        return(presort)
    } else if (str_detect(tolower(out), "weighted")) {
        return(presort)
    } else {
        return(heatmaps)
    }
} #end ProcessHeatmaps

#Make Black Red Heatmaps for small groups of ORs
SubsetBLRH3 <- function(df1, df2, df3, subset, 
                        title = NA, out = "heat", 
                        sort = F, label = F) {
    subset1 <- df1[which(rownames(df1) %in% subset),]
    subset2 <- df2[which(rownames(df2) %in% subset),]
    subset3 <- df3[which(rownames(df3) %in% subset),]
    
    merge <- normNormDF(subset1, subset2, subset3)
    
    if (sort == F) {
        subsort <- tibble(gene = subset, sortrank = length(subset):1, wavgs = NA)
        mergesort <- SortByList(merge, subsort)
    } else if (sort == T) {
        subsort <- MakeSort(subset1, subset2, subset3, method = "posmean")
        mergesort <- SortByList(merge, subsort)
    } #endif
    
    p <- MakeBlackRedHeatmap(mergesort, title)
    if (out == "heat") {
        if (label == T) {
            p <- p  + theme(axis.text.y = element_text(size = 8))
            return(p)
        } else {
            return(p)
        } #endif
    } else if (out == "names") {
        return(subsort)
    } #endif
} #end SubsetBLRH3

SubsetBLRH4 <- function(df1, df2, df3, df4, subset, 
                        title = NA, out = "heat", 
                        sort = F, label = F) {
    subset1 <- df1[which(rownames(df1) %in% subset),]
    subset2 <- df2[which(rownames(df2) %in% subset),]
    subset3 <- df3[which(rownames(df3) %in% subset),]
    subset4 <- df4[which(rownames(df4) %in% subset),]
    
    merge <- normNormDF(subset1, subset2, subset3, subset4)
    
    if (sort == F) {
        subsort <- tibble(gene = subset, sortrank = length(subset):1, wavgs = NA)
        mergesort <- SortByList(merge, subsort)
    } else if (sort == T) {
        subsort <- MakeSort(subset1, subset2, subset3, subset4, method = "posmean")
        mergesort <- SortByList(merge, subsort)
    } #endif
    
    p <- MakeBlackRedHeatmap(mergesort, title)
    if (out == "heat") {
        if (label == T) {
            p <- p + theme(axis.text.y = element_text(size = 8))
            return(p)
        } else {
            return(p)
        } #endif
    } else if (out == "names") {
        return(subsort)
    } #endif
}#end SubsetBLRH4

SubsetBLRH1 <- function(mX, olfrs, title = NA, out = "interactive") {
    subheat <- SubsetBLRH3(mX, mX, mX, olfrs, 
                           title = title, 
                           out = "heat", sort = F, label = T) +
        theme(plot.title = element_text(size = 12))
    if (out == "heat") {
        return(subheat)
    } else if (out == "interactive") {
        inter_subheat <- ggplotly(subheat)
        return(inter_subheat)
    }
} #end SubsetBLRH1

SubsetAllAP <- function(olfrs) {
    ap4sub <- SubsetBLRH1(m4_vnorm, olfrs, title = "m4AP", out = "heat") 
    ap6sub <- SubsetBLRH1(m6_vnorm, olfrs, title = "m6AP", out = "heat")
    ap7sub <- SubsetBLRH1(m7_vnorm, olfrs, title = "m7AP", out = "heat")
    ap10sub <- SubsetBLRH1(m10_vnorm, olfrs, title = "m10AP", out = "heat")
    ap13sub <- SubsetBLRH1(m13_vnorm, olfrs, title = "m13AP", out = "heat")
    ap15sub <- SubsetBLRH1(m15_vnorm, olfrs, title = "m15AP", out = "heat")
    
    allAPstacked <- (ap4sub / ap6sub / ap7sub /ap10sub / ap13sub / ap15sub)
    return(allAPstacked)
} #end SubsetAllAP

SubsetAllMLVD <- function(olfrs) {
    ml8sub <- SubsetBLRH1(m8_vnorm, olfrs, title = "m8ML", out = "heat") 
    ml11sub <- SubsetBLRH1(m11_vnorm, olfrs, title = "m11ML", out = "heat")
    ml16sub <- SubsetBLRH1(m16_vnorm, olfrs, title = "m16ML", out = "heat")
    vd9sub <- SubsetBLRH1(m9_vnorm, olfrs, title = "m9VD", out = "heat")
    vd12sub <- SubsetBLRH1(m12_vnorm, olfrs, title = "m12VD", out = "heat")
    vd14sub <- SubsetBLRH1(m14_vnorm, olfrs, title = "m14VD", out = "heat")
    
    allMLVDstacked <- (ml8sub / ml11sub / ml16sub / vd9sub / vd12sub / vd14sub)
    return(allMLVDstacked)
} #end SubsetAllMLDV

#given 2 matrixes, compute spearman correlation of rows (OR vs OR) 
SpearMatrix <- function(df1, df2) {
    spear_vec <- vector(length = nrow(df1), mode = "numeric")
    for (i in 1:nrow(df1)) {
        spear_vec[i] <- cor(df1[i,], df2[i,], method = "spearman")
    } #endfor
    return(spear_vec)
} #end SpearMatrix

#apply SpearMatrix to multiple matrices(just 3 or 4)
#probably need to rewrite using permutation/combination
MultiSpearMatrix <- function(...){
    args <- list(...)
    
    if (length(args) == 3) {
        mat3 <- matrix(ncol = 3, nrow = nrow(args[[1]]))
        colnames(mat3) <- c("1v2", "1v3", "2v3")
        ornames <- rownames(args[[1]])
        rownames(mat3) <- ornames
        mat3[,1] <- SpearMatrix(args[[1]], args[[2]])
        mat3[,2] <- SpearMatrix(args[[1]], args[[3]])
        mat3[,3] <- SpearMatrix(args[[2]], args[[3]])
        mat3
    } else if(length(args) == 4) {
        mat4 <- matrix(ncol = 6, nrow = nrow(args[[1]]))
        colnames(mat4) <- c("1v2", "1v3", "1v4", "2v3", "2v4", "3v4")
        ornames <- rownames(args[[1]])
        rownames(mat4) <- ornames
        mat4[,1] <- SpearMatrix(args[[1]], args[[2]])
        mat4[,2] <- SpearMatrix(args[[1]], args[[3]])
        mat4[,3] <- SpearMatrix(args[[1]], args[[4]])
        mat4[,4] <- SpearMatrix(args[[2]], args[[3]])
        mat4[,5] <- SpearMatrix(args[[2]], args[[4]])
        mat4[,6] <- SpearMatrix(args[[3]], args[[4]])
        mat4
    } #endif
} #end MultiSpearMatrix

#Find an Anterior Peak and a Posterior Peak
#note that the rank df solves ties using "random" in order to prevent passing a vector when searching for rank X.
AntPeakPostPeak <- function(df_norm) {
    #rank df
    rank_df <- matrix(nrow = nrow(df_norm), ncol = ncol(df_norm))
    for (i in 1:nrow(df_norm)) {
        rank_df[i,] <- rank(desc(df_norm[i,]), ties.method = "random")
    } #endfor
    
    #find max sec
    maxsec <- vector(mode = "numeric", length = nrow(rank_df))
    maxval <- vector(mode = "numeric", length = nrow(rank_df))
    for (i in 1:nrow(rank_df)) {
        for (s in 1:ncol(rank_df)) {
            if (rank_df[i,s] == min(rank_df[i,])) {
                maxsec[i] <- s
                maxval[i] <- df_norm[i,s]
            } #endif
        } #endfor
    } #endfor
    
    #find next
    nextsec <- rep(NA, length(maxsec))
    nextval <- vector(mode = "numeric", length = nrow(rank_df))
    nextmany <- vector(mode = "numeric", length = nrow(rank_df))
    maxsecin <- ncol(rank_df)
    for (i in 1:length(maxsec)) {
        #set findrank
        findrank <- 2
        #set neighbors
        if (maxsec[i] == 1) {
            min_neigh <- 1
            max_neigh <- 2
        } else if (maxsec[i] == maxsecin) {
            min_neigh <- maxsecin - 1
            max_neigh <- maxsecin
        } else {
            min_neigh <- maxsec[i] - 1
            max_neigh <- maxsec[i] + 1
        } #endif
        
        #while we have not found nextsec
        while (is.na(nextsec[i])) {
            potentialsec <- which(rank_df[i,] == findrank)
            #if potentialsec is a neighbor, bump findrank and neighbor
            if (between(potentialsec, min_neigh, max_neigh)) {
                findrank <- findrank + 1
                #bump neighbor
                if (potentialsec == min_neigh) {
                    min_neigh <- min_neigh - 1
                } else if (potentialsec == max_neigh) {
                    max_neigh <- max_neigh + 1
                } #endif
            } else if (between(potentialsec, min_neigh, max_neigh) == FALSE) {
                nextsec[i] <- potentialsec
                nextval[i] <- df_norm[i, potentialsec]
            } else {
                nextsec[i] <- -1
                nextval[i] <- -1
            } #endif
        } #endwhile
    } #endfor
    
    #notate Ant and Post Peaks
    antpeak <- vector(mode = "numeric", length = nrow(rank_df))
    postpeak <- vector(mode = "numeric", length = nrow(rank_df))
    antval <- vector(mode = "numeric", length = nrow(rank_df))
    postval <- vector(mode = "numeric", length = nrow(rank_df))
    for (i in 1:nrow(rank_df)) {
        if (maxsec[i] < nextsec[i]) {
            antpeak[i] <- maxsec[i]
            antval[i] <- maxval[i]
            postpeak[i] <- nextsec[i]
            postval[i] <- nextval[i]
        } else {
            antpeak[i] <- nextsec[i]
            antval[i] <- nextval[i]
            postpeak[i] <- maxsec[i]
            postval[i] <- maxval[i]
        } #endif
    } #endfor
    
    #output
    gene <- rownames(df_norm)
    record <- tibble(gene, antpeak, postpeak, antval, postval)
    return(record)
} #end AntPeakPostPeak

#join APPP output, names should be like "_mX"
MultiAPPP <- function(df1, df2, df3, df4, name1, name2, name3, name4) {
    rec1 <- AntPeakPostPeak(df1)
    rec2 <- AntPeakPostPeak(df2)
    rec3 <- AntPeakPostPeak(df3)
    rec4 <- AntPeakPostPeak(df4)
    join1 <- left_join(rec1, rec2, by = "gene", suffix = c(name1, name2))
    join2 <- left_join(rec3, rec4, by = "gene", suffix = c(name3, name4))
    endjoin <- left_join(join1, join2, by = "gene")
    return(endjoin)
} #end MultiAPPP

#using APPP, take a mean position of peaks
SymLiner <- function(ap, vd, ml, out = "plot") {
    ap_appp <- AntPeakPostPeak(ap)
    vd_appp <- AntPeakPostPeak(vd) %>% 
        rename(venpeak = antpeak,
               dorpeak = postpeak,
               venval = antval,
               dorval = postval)
    ml_appp <- AntPeakPostPeak(ml) %>% 
        rename(medpeak = antpeak,
               latpeak = postpeak,
               medval = antval,
               latval = postval)
    allpeaks <- left_join(ap_appp, vd_appp, by = "gene") %>% 
        left_join(ml_appp, by = "gene")
    
    peakdifs <- allpeaks %>%
        rowwise() %>%
        mutate(apdif = mean(c(antpeak, postpeak)),
               vddif = mean(c(venpeak, dorpeak)),
               mldif = mean(c(medpeak, latpeak))) %>%
        ungroup()
    
    if (out == "plot") {
        plot <- ggplot(peakdifs) +
            geom_point(aes(apdif, mldif, alpha = 0.1)) +
            geom_smooth(aes(apdif, mldif), 
                        method = "lm", formula = y~x, color = "blue") +
            geom_smooth(aes(apdif, mldif), 
                        method = "loess", formula = y~x, 
                        color = "red", se = F) +
            theme(legend.position = "none")
        return(plot)
    } else if (out == "fit") {
        fit <- coef(lm(peakdifs$mldif ~ peakdifs$apdif))
        fitout <- summary(fit)
        return(fit)
    }  else {
        return(peakdifs)
    } #endif
} #end SymLiner

#Make triple heatmap of class, tanzone, and matsunami diff OE
PlotFeatures <- function(sortlistin, featureOut = "trihm") {
    withinfo <- sortlistin %>% 
        left_join(info %>% rename("gene" = "olfrname"), by = "gene") %>% 
        mutate(sortearly = ifelse(sortrank <= max(sortrank)/2, "early", "late"),
               class_fct = as_factor(class),
               rtp_fct = as_factor(RTP),
               fisur_fct = factor(fisurface, levels = c("TRUE", "FALSE")),
               type = ifelse(str_detect(gene, "Olfr"), "Olfr", "Taar"),
               type_fct = factor(type, levels = c("Taar", "Olfr")))
    
    stats_oe <- withinfo %>% 
        filter(!is.na(oe_region)) %>% 
        select(sortearly, oe_region) %>% 
        group_by(sortearly) %>% 
        count(oe_region) %>% 
        arrange(desc(n)) %>%
        pivot_wider(names_from = sortearly, values_from = n) %>% 
        as.matrix() 
    stats_oe <- stats_oe[,-1]
    class(stats_oe) <- "numeric"
    test_oe <- fisher.test(stats_oe)
    pval_oe <- format(test_oe$p.value, digits = 5)
    odds_oe <- format(test_oe$estimate, digits = 3)
    
    stats_class <- withinfo %>% 
        filter(!is.na(class)) %>% 
        select(sortearly, class) %>% 
        group_by(sortearly) %>% 
        count(class) %>% 
        arrange(desc(n)) %>%
        pivot_wider(names_from = sortearly, values_from = n) %>% 
        as.matrix()
    stats_class <- stats_class[,-1]
    class(stats_class) <- "numeric"
    test_class <- fisher.test(stats_class)
    pval_class <- format(test_class$p.value, digits = 5)
    odds_class <- format(test_class$estimate, digits = 3)
    
    stats_fi <- withinfo %>% 
        filter(!is.na(fisurface)) %>% 
        select(sortearly, fisurface) %>% 
        group_by(sortearly) %>% 
        count(fisurface) %>% 
        arrange(desc(n)) %>%
        pivot_wider(names_from = sortearly, values_from = n) %>% 
        as.matrix()
    stats_fi <- stats_fi[,-1]
    class(stats_fi) <- "numeric"
    test_fi <- fisher.test(stats_fi)
    pval_fi <- format(test_fi$p.value, digits = 5)
    odds_fi <- format(test_fi$estimate, digits = 3)
    
    stats_tanvd <- withinfo %>% 
        filter(!is.na(tz_vd)) %>% 
        select(sortearly, tz_vd) %>% 
        group_by(sortearly) %>% 
        count(tz_vd) %>% 
        arrange(desc(n)) %>%
        pivot_wider(names_from = sortearly, values_from = n) %>% 
        as.matrix()
    stats_tzvd <- stats_tanvd[,-1]
    class(stats_tzvd) <- "numeric"
    test_tzvd <- fisher.test(stats_tzvd)
    pval_tzvd <- format(test_tzvd$p.value, digits = 5)
    odds_tzvd <- format(test_tzvd$estimate, digits = 3)
    
    stats_rtp <- withinfo %>% 
        filter(!is.na(RTP)) %>% 
        filter(RTP != "ns") %>%
        select(sortearly, RTP) %>% 
        group_by(sortearly) %>% 
        count(RTP) %>% 
        arrange(desc(n)) %>%
        pivot_wider(names_from = sortearly, values_from = n) %>% 
        as.matrix() 
    stats_rtp <- stats_rtp[,-1]
    class(stats_rtp) <- "numeric"
    test_rtp <- fisher.test(stats_rtp)
    pval_rtp <- format(test_rtp$p.value, digits = 5)
    odds_rtp <- format(test_rtp$estimate, digits = 3)
    
    stats_type <- withinfo %>% 
        filter(!is.na(type)) %>% 
        filter(type_fct != "ns") %>%
        select(sortearly, type_fct) %>% 
        group_by(sortearly) %>% 
        count(type_fct) %>% 
        arrange(desc(n)) %>%
        pivot_wider(names_from = sortearly, values_from = n) %>% 
        as.matrix() 
    stats_type <- stats_type[,-1]
    class(stats_type) <- "numeric"
    test_type <- fisher.test(stats_type)
    pval_type <- format(test_type$p.value, digits = 5)
    odds_type <- format(test_type$estimate, digits = 3)
    
    
    sorttanzone <- withinfo %>% 
        select(gene, tz_val) %>% 
        filter(!is.na(tz_val)) %>% 
        as.matrix()
    rownames(sorttanzone) <- sorttanzone[,1]
    trimtanzone <- sorttanzone[,2]
    trimtanzone <- as.numeric(trimtanzone)
    
    df_df <- as.data.frame(trimtanzone)
    df_df$target = rownames(df_df)
    df_melt <- melt(df_df, id.vars ="target")
    names(df_melt)[2:3] <- c("Feature", "value")
    #make genelist into character vector
    df_melt$target <- as.character(df_melt$target)
    df_melt$target <- factor(df_melt$target, levels=unique(df_melt$target))
    
    tan <- ggplot(df_melt, aes(Feature, target, height = 3)) + 
        geom_tile(aes(fill = value), color = "grey") +
        scale_fill_viridis() +
        guides(fill = guide_legend(nrow = 1)) +
        theme(plot.margin = unit(c(1,1,1,1), "cm"),
              legend.title = element_text(size = 12, vjust = 1),
              legend.text = element_text(size = 6),
              legend.position = c(0.5, -0.1),
              plot.title = element_text(size = 20),
              axis.title.x = element_blank(),
              axis.title.y = element_text(size = 15, vjust = 0, face="bold"),
              axis.text.x = element_text(angle = 330, hjust = 0, vjust = 2, size = 0),
              axis.text.y = element_text(size = 0),
              axis.ticks = element_blank()) +
        labs(fill = "MiyIndex")
    
    tan_vd <- ggplot(withinfo %>% filter(!is.na(tz_vd)),
                     aes(tz_vd, sortrank, fill = tz_vd)) +
        geom_violin() +
        xlab(paste("Tan Zone Dorsal Ventral", 
                   paste0("p = ", pval_oe), 
                   paste0("odds = ", odds_oe),
                   sep = "\n")) +
        scale_fill_manual(values=c("red", "black")) +
        theme_cowplot() +
        theme(legend.position = "none",
              axis.line = element_blank(),
              axis.ticks.x = element_blank(),
              axis.ticks.y = element_blank(),
              axis.text.y = element_blank(),
              axis.title.y = element_blank())
    
    oe <- ggplot(withinfo %>% filter(!is.na(oe_region)), 
                 aes(oe_region, sortrank, fill = oe_region)) +
        geom_violin() +
        xlab(paste("Matsunami OE DiffE", 
                   paste0("p = ", pval_tzvd), 
                   paste0("odds = ", odds_tzvd),
                   sep = "\n")) +
        scale_fill_manual(values=c("red", "black")) +
        theme_cowplot() +
        theme(legend.position = "none",
              axis.line = element_blank(),
              axis.ticks.x = element_blank(),
              axis.ticks.y = element_blank(),
              axis.text.y = element_blank(),
              axis.title.y = element_blank())
    
    class <- ggplot(withinfo %>% filter(!is.na(class_fct)), 
                    aes(class_fct, sortrank, fill = class_fct)) +
        geom_violin() +
        xlab(paste("Class", 
                   paste0("p = ", pval_class), 
                   paste0("odds = ", odds_class),
                   sep = "\n")) +
        scale_fill_manual(values=c("red", "black")) +
        theme_cowplot() +
        theme(legend.position = "none",
              axis.line = element_blank(),
              axis.ticks.x = element_blank(),
              axis.ticks.y = element_blank(),
              axis.text.y = element_blank(),
              axis.title.y = element_blank())
    
    taar <- ggplot(withinfo %>% filter(!is.na(type)),
                   aes(type_fct, sortrank, fill = type_fct)) +
        geom_violin() +
        xlab(paste("Gene Family", 
                   paste0("p = ", pval_type), 
                   paste0("odds = ", odds_type),
                   sep = "\n")) +
        scale_fill_manual(values = c("red", "black")) +
        theme_cowplot() +
        theme(axis.line = element_blank(),
              axis.ticks.x = element_blank(),
              axis.ticks.y = element_blank(),
              axis.text.y = element_blank(),
              axis.title.y = element_blank(),
              legend.position = "none")
    
    FIsurface <- ggplot(withinfo %>% filter(!is.na(fisurface)),
                        aes(fisur_fct, sortrank, fill = fisur_fct)) +
        geom_violin() +
        xlab(paste("FI surface enriched", 
                   paste0("p = ", pval_fi), 
                   paste0("odds = ", odds_fi),
                   sep = "\n")) +
        scale_fill_manual(values=c("red", "black")) +
        theme_cowplot() +
        theme(legend.position = "none",
              axis.line = element_blank(),
              axis.ticks.x = element_blank(),
              axis.ticks.y = element_blank(),
              axis.text.y = element_blank(),
              axis.title.y = element_blank())
    
    #typically used as a quick control
    RTP <- ggplot(withinfo %>% 
                      filter(!is.na(RTP)) %>% 
                      filter(RTP != "ns"),
                  aes(rtp_fct, sortrank, fill = rtp_fct)) +
        geom_violin() +
        xlab(paste("RTP u/oOR", 
                   paste0("p = ", pval_rtp), 
                   paste0("odds = ", odds_rtp),
                   sep = "\n")) +
        scale_fill_manual(values=c("red", "black", "blue")) +
        theme_cowplot() +
        theme(legend.position = "none",
              axis.line = element_blank(),
              axis.ticks.x = element_blank(),
              axis.ticks.y = element_blank(),
              axis.text.y = element_blank(),
              axis.title.y = element_blank())
    
    if (featureOut == "trihm") {
        trihm <- tan + oe + class
        return(trihm)
    } else if (featureOut == "trivio") {
        trivio <- tan_vd + oe + class
        return(trivio)
    } else if (featureOut == "tan1") {
        return(tan)
    } else if (featureOut == "tan2") {
        return(tanvd)
    } else if (featureOut == "rtp") {
        return(RTP)
    } else if (featureOut == "oe") {
        return(oe)
    } else if (featureOut == "class") {
        return(class)
    } else if (featureOut == "fi") {
        return(FIsurface)
    } else if (featureOut == "taar") {
        return(taar)
    } else if (featureOut == "quadbox") {
        quadbox <- (tan_vd + class) / (taar + FIsurface)
        return(quadbox)
    } #endif 
} #end PlotFeatures

#Plot two sets of random ORs as a mental control for other features
PlotRandom <- function(sortlistin, x = 200, y = 225, 
                       out = "plot") {
    withinfo <- sortlistin %>% 
        left_join(info %>% 
                      rename("gene" = "olfrname"), by = "gene") %>% 
        mutate(sortearly = ifelse(sortrank <= max(sortrank)/2, "early", "late"))
    
    #get random OR sets and give them a feature
    random_names <- withinfo %>% pull(gene)
    getxy <- sample(random_names, size = x+y)
    xnames <- getxy[1:x]
    ynames <- getxy[(x+1):y]
    
    random_set <- withinfo %>%
        mutate(inXinY = ifelse(gene %in% xnames, "X", 
                               ifelse(gene %in% ynames, "Y", NA))) %>%
        filter(!is.na(inXinY))
    
    stats_random <- random_set %>% 
        select(sortearly, inXinY) %>% 
        group_by(sortearly) %>% 
        count(inXinY) %>% 
        arrange(desc(n)) %>%
        pivot_wider(names_from = sortearly, values_from = n) %>% 
        as.matrix()
    stats_random <- stats_random[,-1]
    class(stats_random) <- "numeric"
    test_random <- fisher.test(stats_random)
    pval_random <- format(test_random$p.value, digits = 5)
    odds_random <- format(test_random$estimate, digits = 3)
    random_stat <- c(pval_random, odds_random)
    
    random_violin <- ggplot(random_set, 
                            aes(inXinY, sortrank, fill = inXinY)) +
        geom_violin() +
        ylab(paste("Randomly picked ORs", 
                   paste0("p = ", pval_random), 
                   paste0("odds = ", odds_random),
                   sep = "\n")) +
        scale_fill_manual(values=c("red", "black")) +
        theme_cowplot() +
        theme(legend.position = "none",
              axis.line = element_blank(),
              axis.ticks.x = element_blank(),
              axis.ticks.y = element_blank(),
              axis.text.y = element_blank(),
              axis.title.y = element_blank())
    
    if (str_detect(tolower(out), "stat"))
        return(random_stat)
    else {
        return(random_violin)
    } #endif
} #end PlotRandom

#check if expression of OR across sections is uniform in distribution using ks.test(x, "punif)$p.value > 0.05
UniformityFilter <- function(df, ranklist = NA, rounds = 10, out = "plot") {
    kstest_df <- matrix(nrow = nrow(df), ncol = 2*rounds)
    colnames(kstest_df) <- rep(c("Pval", "Dval"), each = rounds)
    
    for (r in 1:rounds) {
        #deal with ties for ks.test() input
        pseudocount <- runif(ncol(df), 0, 0.0001)
        
        for (i in 1:nrow(df)) {
            orexp <- df[i,]
            orexpPC <- orexp + pseudocount
            test <- ks.test(orexpPC, "punif")
            kstest_df[i,r] <- test$p.value
            kstest_df[i,rounds + r] <- test$statistic
        } #endfor
    } #endfor
    
    #distribution is uniform if kstest p value is not significant
    stat_all <- suppressMessages(as_tibble(kstest_df, .name_repair = "unique"))
    pmean <- stat_all %>% 
        select(contains("Pval")) %>%
        mutate(meanPval = rowMeans(.)) %>%
        pull(meanPval)
    
    dmean <- stat_all %>%
        select(contains("Dval")) %>%
        mutate(meanDval = rowMeans(.)) %>%
        pull(meanDval)
    
    stat_tib <- tibble(gene = rownames(df),
                       meanPval = pmean,
                       meanDval = dmean,
                       isUniform = ifelse(meanPval > 0.05, T, F))
    
    uniform_ORs <- stat_tib %>% filter(isUniform == T) %>% pull(gene)
    notuniform_ORs <- stat_tib %>% filter(isUniform == F) %>% pull(gene)
    
    uniform_len <- length(uniform_ORs)
    notuniform_len <- length(notuniform_ORs)
    
    uniform_df <- df[which(stat_tib$isUniform == T),]
    notuniform_df <- df[-which(stat_tib$isUniform == T),]
    
    if (str_detect(tolower(out), "plot")) {
        if (nrow(uniform_df) == 0) {
            return(stat_tib)
        }  #endif
        
        uniform_sort <- SortByList(uniform_df, ranklist)
        notuniform_sort <- SortByList(notuniform_df, ranklist)
        uniform_hm <- MakeBlackRedHeatmap(uniform_sort, 
                                          title = paste0(uniform_len, 
                                                         " Uniform ORs"))
        notuniform_hm <- MakeBlackRedHeatmap(notuniform_sort, 
                                             title = paste0(notuniform_len, 
                                                            " Non-Uniform ORs"))
        both_hm <- uniform_hm + notuniform_hm
        return(both_hm)
    } else if (str_detect(tolower(out), "stat")) {
        return(stat_tib)
    } else {
        return(uniform_ORs)
    } #endif
} #end UniformityFilter

#function for distance between 3d points
Dist3d <- function(df, row1, row2) {
    distance <- sqrt((df$AntPos[row1] - df$AntPos[row2])^2 +
                         (df$MedLat[row1] - df$MedLat[row2])^2 + 
                         (df$VenDor[row1] - df$VenDor[row2])^2)
    return(distance)
} #end Dist3d

#data for correlation matrix split into X many tree groups
PlotBranches <- function(branches) {
    dend <- hclust(dist(meanpos_cor, method = "euclidean"), method = "complete")
    
    #2d stuff
    branchheatmaps <- vector("list", length = branches)
    branchsize <- vector("numeric", length = branches)
    branchcor <- vector("numeric", length = branches)
    #3d stuff
    branch3d <- vector("list", length = branches)
    branchMdist <- vector("list", length = branches)
    branchLdist <- vector("list", length = branches)
    branchavgdist <- vector("numeric", length = branches)
    
    for (i in 1:branches) {
        if (i %% 50 == 0) {
            message(i)
        } #endif
        names <- names(which(cutree(dend, k = branches) == i))
        
        #remove ectopic
        ectopic <- c("Olfr32", "Olfr287")
        #checking for 1 at a time due to warning: the condition has length > 1 and only first element will be used
        if (max(ectopic %in% names) == 1) {
            names <- names[-which(names %in% ectopic)]
        } #endif
        
        branchsize[i] <- length(names)
        
        if(branchsize[i] > 1){
            title_ap <- paste("AP-branch", as.character(i), sep = "")
            title_ml <- paste("ML-branch", as.character(i), sep = "")
            title_vd <- paste("VD-branch", as.character(i), sep = "")
            
            ap_plot <- SubsetBLRH4(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, 
                                   names, title = title_ap)
            ml_plot <- SubsetBLRH4(m8_Vnorm, m11_Vnorm, m8_Vnorm, m11_Vnorm,
                                   names, title = title_ml)
            vd_plot <- SubsetBLRH3(m9_Vnorm, m12_Vnorm, m14_Vnorm, 
                                   names, title = title_vd)
            branchheatmaps[[i]] <- ap_plot + ml_plot + vd_plot
            
            #branchcor mean includes 1.0 values from ORx vs ORx
            branchcor[i] <- mean(meanpos_cor[which(rownames(meanpos_cor) %in% names),
                                             which(colnames(meanpos_cor) %in% names)])
            #branch3d[[i]] <- ListML(names, "point")
            
            #calculate distance between points for ORs in group
            # data4dist <- ListDorML(names, out = "data") %>% 
            #   filter(p50 == clustmaxp)
            # dataMdist <- data4dist %>% 
            #   filter(side == "Medial") %>%
            #   unique()
            # dataLdist <- data4dist %>%
            #   filter(side == "Lateral") %>%
            #   unique()
            # permM <- permutations(n=nrow(dataMdist), r=2)
            # permL <- permutations(n=nrow(dataLdist), r=2)
            # someM <- vector("numeric", length = nrow(permM))
            # someL <- vector("numeric", length = nrow(permL))
            # 
            # for (m in 1:nrow(permM)) {
            #   someM[m] <- Dist3d(dataMdist, permM[m,1], permM[m,2])
            # } #endfor
            # 
            # for (l in 1:nrow(permL)) {
            #   someL[l] <- Dist3d(dataLdist, permL[l,1], permL[l,2])
            # } #endfor
            # 
            # branchMdist[[i]] <- someM
            # branchLdist[[i]] <- someL
            # branchavgdist[i] <- mean(c(someM, someL))
            
        } else {
            branchcor[i] <- NA
            branchheatmaps[[i]] <- NA
            branchMdist[[i]] <- NA
            branchLdist[[i]] <- NA
            branchavgdist[i] <- NA
            branch3d[[i]] <- DorsalML(olfr = names)
        } #endif
    } #endfor
    
    branchout <- list(branchsize, branchcor, branchheatmaps, 
                      branchMdist, branchLdist, branchavgdist, branch3d)
    names(branchout) <- c("size", "cor", "heatmaps", 
                          "med_dist", "lat_dist", "avg_dist", "3D")
    return(branchout)
} #end PlotBranches
```


```{r message=F, warning=F}
#load data
allmice_tpm <- read_csv("~/Desktop/obmap/r_analysis/data/make_TPMmtx/covarintactchemo3_over_samples_210429.csv") %>%
    filter(rep != 13) %>%
    filter(rep != 15)

#make new covars
blankdata <- readRDS("~/Desktop/obmap/r_analysis/data/mri_to_R/210404_voxV4b_strip25_straightMdoubled_outeronly_rescaled.RDS")
cntAP <- blankdata %>% group_by(AntPos) %>% summarise(count = n(), weight = count/nrow(blankdata)) %>% mutate(dim = "AntPos") %>% rename("slice" = "AntPos")
cntML <- blankdata %>% group_by(MedLat) %>% summarise(count = n(), weight = count/nrow(blankdata)) %>% mutate(dim = "MedLat") %>% rename("slice" = "MedLat")
cntVD <- blankdata %>% group_by(VenDor) %>% summarise(count = n(), weight = count/nrow(blankdata)) %>% mutate(dim = "VenDor") %>% rename("slice" = "VenDor")
cntall <- bind_rows(cntAP, cntML) %>% bind_rows(cntVD)

allmice_covars <- allmice_tpm %>% left_join(cntall, by = c("dim", "slice")) %>% select(name, rep, slice, dim, dimrep, count, weight)

#visualize weights
allmice_covars %>% filter(dimrep == 1) %>% ggplot() + geom_line(aes(slice, weight)) + facet_wrap(~dim)

symline <- read_csv("~/Desktop/obmap/r_analysis/data/3dimOB/model/symline_3rep.csv")

info <- read_csv("~/Desktop/info_210430.csv")

totaltpm_norms <- readRDS("~/Desktop/obmap/r_analysis/data/make_TPMmtx/totalORtpm_normalizations_justname_210404.RDS")

#norms used for dtvt_vox4B_OConly model, since OConly would be nice to recalculate for all samples so can make all heatmaps, but fine for today
dtvt_norms <- readRDS("~/Desktop/obmap/r_analysis/data/3dimOB/model/210404_vox4B_wt_dtvt_OConly.RDS") 
new_norms <- read_csv("~/Desktop/obmap/r_analysis/data/make_TPMmtx/weights_proptotal_210424.csv")
ompvoxnorms <- read_csv("~/Desktop/obmap/r_analysis/data/3dimOB/model/omp_olfr_voxweights_dv22.csv")

allmice_ortaar <- allmice_tpm %>% select(name:dimrep, contains(c("Olfr", "Taar")))

set.seed(711)
```

# mean tpm across all sections

```{r}
#calculate average TPM of an OR across all sections
or_mean_all <- vector(length = ncol(allmice_ortaar), mode = "numeric")
for (i in 1:ncol(allmice_ortaar)) {
    if (i < 6) {
        or_mean_all[i] <- NA
    } else {
        or_mean_all[i] <- sum(allmice_ortaar[,i])/nrow(allmice_ortaar)
    }
}

#plot how many ORs below each TPM cutoff
ors_below <- vector(length = 100, mode = "numeric")
below_num <- vector(length = 100, mode = "numeric")
for (i in 1:100) {
    ors_below[i] <- length(which(or_mean_all < 2*i))
    below_num[i] <- 2*i
}
ors_below_num <- data.frame(below_num, ors_below)

ggplot(ors_below_num, aes(below_num, ors_below)) + 
    geom_point()
```

# filter ORs by: uniformity, zero in a replicate, mean of all sections \< 1tpm

```{r}
#some ORs in some replicates have only 0 tpm
mean_byrep <- matrix(nrow = ncol(allmice_ortaar) - 5, 
                     ncol = length(unique(allmice_ortaar$rep)))
reps <- unique(allmice_ortaar$rep)
for (i in 1:length(reps)) {
    rep_tib <- allmice_ortaar %>% filter(rep == reps[i])
    for (j in 6:ncol(rep_tib)) {
        mean_byrep[j-5,i] <- sum(rep_tib[,j]/nrow(rep_tib))
    }
}
rownames(mean_byrep) <- colnames(allmice_ortaar)[6:ncol(allmice_ortaar)]
colnames(mean_byrep) <- reps

maxes_byrep <- matrix(nrow = ncol(allmice_ortaar) - 5, 
                     ncol = length(unique(allmice_ortaar$rep)))
reps <- unique(allmice_ortaar$rep)
for (i in 1:length(reps)) {
    rep_tib <- allmice_ortaar %>% filter(rep == reps[i])
    for (j in 6:ncol(rep_tib)) {
        maxes_byrep[j-5,i] <- max(rep_tib[,j])
    }
}
rownames(maxes_byrep) <- colnames(allmice_ortaar)[6:ncol(allmice_ortaar)]
colnames(maxes_byrep) <- reps

zero_inrep <- which(mean_byrep == 0, arr.ind = T)
zero_inrep_tb <- tibble(gene = rownames(zero_inrep),
                        rep = zero_inrep[,2])

zero_inrep_ORs <- zero_inrep_tb %>%
    group_by(gene) %>% 
    count() %>%
    filter(n > 0) %>%
    ungroup() %>%
    pull(gene)

#ectopic ORs
ectopic_ORs <- c("Olfr287", "Olfr32", "Olfr361", "Olfr1033")

#ORs with a mean below 1tpm in all sections
below1_OR_vals <- or_mean_all[which(or_mean_all < 1)]
below1_ORs <- colnames(allmice_ortaar)[which(or_mean_all < 1)]
below1_maxes <- maxes_byrep[which(rownames(maxes_byrep) %in% below1_ORs),]

b1_min <- vector(length = nrow(below1_maxes), mode = "numeric")
b1_mean <- vector(length = nrow(below1_maxes), mode = "numeric")
b1_max <- vector(length = nrow(below1_maxes), mode = "numeric")
for (i in 1:nrow(below1_maxes)) {
    b1_min[i] <- min(below1_maxes[i,])
    b1_mean[i] <- mean(below1_maxes[i,])
    b1_max[i] <- max(below1_maxes[i,])
}

b1_tb <- tibble(gene = rownames(below1_maxes),
                mean_val = below1_OR_vals,
                min_rep = b1_min,
                mean_rep = b1_mean,
                max_rep = b1_max) %>%
    mutate(min_gt_mV = ifelse(min_rep > mean_val, T, F),
           mean_over_mean = mean_rep / mean_val,
           max_over_mean = max_rep / mean_val)

below1mingoodtho <- b1_tb %>% filter(min_gt_mV == F) %>% pull(gene)

#ORs with uniform distribution in a replicate
uniform_ORs <- readRDS("~/Desktop/heatmaps/ompdv22no1315_uni2.RDS")

filter_ORs <- unique(c(ectopic_ORs, below1mingoodtho, zero_inrep_ORs, uniform_ORs))
length(filter_ORs)
saveRDS(filter_ORs, "~/Desktop/heatmaps/filterORs_ompdv22no1315_uni2_ect4_below1mingt_zer0.RDS")

allmice_final <- allmice_ortaar %>% select(-all_of(filter_ORs))

#using 24 to start as it falls early on the curve and removes 350 ORs
#previous version used [,-which(or_mean_all < 10)] 
alldim_ap_tpm_cut <- allmice_final %>% filter(dim == "AntPos")
alldim_ml_tpm_cut <- allmice_final %>% filter(dim == "MedLat")
alldim_vd_tpm_cut <- allmice_final %>% filter(dim == "VenDor")
```

# ANTERIOR-POSTERIOR

```{r}
#normalize values
m4_tpm <- alldim_ap_tpm_cut %>% filter(rep == 4) %>% select(-name, -rep, -dim, -dimrep)
m6_tpm <- alldim_ap_tpm_cut %>% filter(rep == 6) %>% select(-name, -rep, -dim, -dimrep)
m7_tpm <- alldim_ap_tpm_cut %>% filter(rep == 7) %>% select(-name, -rep, -dim, -dimrep)
m10_tpm <- alldim_ap_tpm_cut %>% filter(rep == 10) %>% select(-name, -rep, -dim, -dimrep)
#m13_tpm <- alldim_ap_tpm_cut %>% filter(rep == 13) %>% select(-name, -rep, -dim, -dimrep)
#m15_tpm <- alldim_ap_tpm_cut %>% filter(rep == 15) %>% select(-name, -rep, -dim, -dimrep)

#AP Weights
ompNorms <- c(2.618,1.259,0.864,0.636,0.858,0.585,0.68,1.19,0.961,0.943,
              0.985,1.093,0.898,1.199,0.829,1.061,0.856,0.984,0.908,0.888,
              1.054,0.895,0.754)
ap_voxweights <- allmice_covars %>% filter(rep == 4) %>% select(slice, weight) %>% mutate(weightflip = 1/weight) %>% pull(weightflip)
dtvt_ap <- dtvt_norms %>% filter(rep == 4) %>% arrange(slice) %>% pull(weight)

apomp <- ompvoxnorms %>% filter(rep == 6) %>% arrange(slice) %>% pull(omprepvox)

m4w <- ompvoxnorms %>% filter(rep == 4) %>% arrange(slice) %>% pull(omprepvox)
m6w <- ompvoxnorms %>% filter(rep == 6) %>% arrange(slice) %>% pull(omprepvox)
m7w <- ompvoxnorms %>% filter(rep == 7) %>% arrange(slice) %>% pull(omprepvox)
m10w <- ompvoxnorms %>% filter(rep == 10) %>% arrange(slice) %>% pull(omprepvox)
#m13w <- ompvoxnorms %>% filter(rep == 13) %>% arrange(slice) %>% pull(omprepvox)
#m15w <- ompvoxnorms %>% filter(rep == 15) %>% arrange(slice) %>% pull(omprepvox)

m4_vnorm <- NormByVector(m4_tpm, m4w)
m6_vnorm <- NormByVector(m6_tpm, m6w)
m7_vnorm <- NormByVector(m7_tpm, m7w)
m10_vnorm <- NormByVector(m10_tpm, m10w)
#m13_vnorm <- NormByVector(m13_tpm, m13w)
#m15_vnorm <- NormByVector(m15_tpm, m15w)

oc_sort <- MakeSort(m4_vnorm, m6_vnorm, m7_vnorm, m10_vnorm)
#nc_sort <- MakeSort(m13_vnorm, m15_vnorm, m13_vnorm, m15_vnorm)
#ocnc_sort <- MakeSort(m4_vnorm, m7_vnorm, m13_vnorm, m15_vnorm)

m4_ocs <- SortByList(m4_vnorm, oc_sort)
m6_ocs <- SortByList(m6_vnorm, oc_sort)
m7_ocs <- SortByList(m7_vnorm, oc_sort)
m10_ocs <- SortByList(m10_vnorm, oc_sort)

#m13_ncs <- SortByList(m13_vnorm, nc_sort)
#m15_ncs <- SortByList(m15_vnorm, nc_sort)

#m4_ds <- SortByList(m4_vnorm, ocnc_sort)
#m6_ds <- SortByList(m6_vnorm, ocnc_sort)
#m7_ds <- SortByList(m7_vnorm, ocnc_sort)
#m10_ds <- SortByList(m10_vnorm, ocnc_sort)
#m13_ds <- SortByList(m13_vnorm, ocnc_sort)
#m15_ds <- SortByList(m15_vnorm, ocnc_sort)

h4o <- MakeBlackRedHeatmap(m4_ocs)
h6o <- MakeBlackRedHeatmap(m6_ocs)
h7o <- MakeBlackRedHeatmap(m7_ocs)
h10o <- MakeBlackRedHeatmap(m10_ocs)
#h13n <- MakeBlackRedHeatmap(m13_ncs)
#h15n <- MakeBlackRedHeatmap(m15_ncs)
#h4d <- MakeBlackRedHeatmap(m4_ds)
#h6d <- MakeBlackRedHeatmap(m6_ds)
#h7d <- MakeBlackRedHeatmap(m7_ds)
#h10d <- MakeBlackRedHeatmap(m10_ds)
#h13d <- MakeBlackRedHeatmap(m13_ds)
#h15d <- MakeBlackRedHeatmap(m15_ds)


#best looking of 4 inputs
apmerge <- normNormDF(m4_vnorm, m6_vnorm,
                      m7_vnorm, m10_vnorm, 
                      calc = "median", median4 = "addmean") %>%
    SortByList(oc_sort) %>% 
    MakeBlackRedHeatmap()
#feature plots
#OR features
apfeats <- PlotFeatures(oc_sort, featureOut = "quadbox")
#RTP control
aprtp <- PlotFeatures(oc_sort, featureOut = "rtp")
#random control
aprandom <- PlotRandom(oc_sort)

#test 200 random selections
random_iter <- 50
ap_random_stats <- matrix(nrow = random_iter, ncol = 2)
for (i in 1:random_iter) {
    i_out <- as.numeric(PlotRandom(oc_sort, out = "stat"))
    ap_random_stats[i,1] <- i_out[1]
    ap_random_stats[i,2] <- i_out[2]
} #endfor

#mean pval is:
mean(ap_random_stats[,1])

#mean odds ratio is:
mean(ap_random_stats[,2])

merge_vnorm_raw <- normNormDF(m4_vnorm, m6_vnorm,
                      m7_vnorm, m10_vnorm, 
                      calc = "median", median4 = "addmean") %>%
    SortByList(oc_sort)

colnames(merge_vnorm_raw) <- c("s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10",
               "s11", "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20",
               "s21", "s22", "s23")
```


# if we center each OR, where do top ranked sections land?
```{r}
middle <- oc_sort
mergedat <- merge_vnorm_raw

mergerank <- matrix(nrow = nrow(mergedat), ncol = ncol(mergedat))
for (i in 1:nrow(mergedat)) {
    mergerank[i,] <- rank(desc(mergedat[i,]), ties.method = "random")
}

which1 <- vector(mode = "numeric", length = nrow(mergerank))
which2 <- vector(mode = "numeric", length = nrow(mergerank))
which3 <- vector(mode = "numeric", length = nrow(mergerank))
which4 <- vector(mode = "numeric", length = nrow(mergerank))
which5 <- vector(mode = "numeric", length = nrow(mergerank))
which6 <- vector(mode = "numeric", length = nrow(mergerank))
which7 <- vector(mode = "numeric", length = nrow(mergerank))
which8 <- vector(mode = "numeric", length = nrow(mergerank))
which9 <- vector(mode = "numeric", length = nrow(mergerank))
which10 <- vector(mode = "numeric", length = nrow(mergerank))
which11 <- vector(mode = "numeric", length = nrow(mergerank))
which12 <- vector(mode = "numeric", length = nrow(mergerank))
which13 <- vector(mode = "numeric", length = nrow(mergerank))
which14 <- vector(mode = "numeric", length = nrow(mergerank))
which15 <- vector(mode = "numeric", length = nrow(mergerank))
which16 <- vector(mode = "numeric", length = nrow(mergerank))
which17 <- vector(mode = "numeric", length = nrow(mergerank))
which18 <- vector(mode = "numeric", length = nrow(mergerank))
which19 <- vector(mode = "numeric", length = nrow(mergerank))
which20 <- vector(mode = "numeric", length = nrow(mergerank))
which21 <- vector(mode = "numeric", length = nrow(mergerank))
which22 <- vector(mode = "numeric", length = nrow(mergerank))
which23 <- vector(mode = "numeric", length = nrow(mergerank))

for (i in 1:nrow(mergerank)) {
    which1[i] <- which(mergerank[i,] == 1)
    which2[i] <- which(mergerank[i,] == 2)
    which3[i] <- which(mergerank[i,] == 3)
    which4[i] <- which(mergerank[i,] == 4)
    which5[i] <- which(mergerank[i,] == 5)
    which6[i] <- which(mergerank[i,] == 6)
    which7[i] <- which(mergerank[i,] == 7)
    which8[i] <- which(mergerank[i,] == 8)
    which9[i] <- which(mergerank[i,] == 9)
    which10[i] <- which(mergerank[i,] == 10)
    which11[i] <- which(mergerank[i,] == 11)
    which12[i] <- which(mergerank[i,] == 12)
    which13[i] <- which(mergerank[i,] == 13)
    which14[i] <- which(mergerank[i,] == 14)
    which15[i] <- which(mergerank[i,] == 15)
    which16[i] <- which(mergerank[i,] == 16)
    which17[i] <- which(mergerank[i,] == 17)
    which18[i] <- which(mergerank[i,] == 18)
    which19[i] <- which(mergerank[i,] == 19)
    which20[i] <- which(mergerank[i,] == 20)
    which21[i] <- which(mergerank[i,] == 21)
    which22[i] <- which(mergerank[i,] == 22)
    which23[i] <- which(mergerank[i,] == 23)
}

merge_tb <- tibble(gene = middle$gene, 
                   ap_wavg = middle$wavgs,
                   ap_rank = middle$sortrank,
                   place1 = which1,
                   place2 = which2,
                   place3 = which3,
                   place4 = which4, 
                   place5 = which5,
                   place6 = which6,
                   place7 = which7,
                   place8 = which8,
                   place9 = which9,
                   place10 = which10,
                   place11 = which11, 
                   place12 = which12,
                   place13 = which13,
                   place14 = which14,
                   place15 = which15,
                   place16 = which16, 
                   place17 = which17,
                   place18 = which18,
                   place19 = which19,
                   place20 = which20,
                   place21 = which21, 
                   place22 = which22,
                   place23 = which23) %>%
    mutate(ap_center = round(ap_wavg)) %>%
    select(gene, ap_wavg, ap_center, contains("place"), ap_rank) %>%
    mutate(rank1 = place1 - ap_center,
           rank2 = place2 - ap_center,
           rank3 = place3 - ap_center,
           rank4 = place4 - ap_center,
           rank5 = place5 - ap_center,
           rank6 = place6 - ap_center,
           rank7 = place7 - ap_center,
           rank8 = place8 - ap_center,
           rank9 = place9 - ap_center,
           rank10 = place10 - ap_center,
           rank11 = place11 - ap_center,
           rank12 = place12 - ap_center,
           rank13 = place13 - ap_center,
           rank14 = place14 - ap_center,
           rank15 = place15 - ap_center,
           rank16 = place16 - ap_center,
           rank17 = place17 - ap_center,
           rank18 = place18 - ap_center,
           rank19 = place19 - ap_center,
           rank20 = place20 - ap_center,
           rank21 = place21 - ap_center,
           rank22 = place22 - ap_center,
           rank23 = place23 - ap_center) %>%
    pivot_longer(names_to = "Hmm", values_to = "Distance", cols = starts_with("rank")) %>%
    rowwise() %>% 
    mutate(order = as.numeric(str_split(Hmm, "k")[[1]][2])) %>% 
    filter(order <= 20)

one2twenty_legend <- ggplot(merge_tb) + geom_histogram(aes(Distance, fill = order), binwidth = 1) + labs(x = "Distance (Sections)", y = "OR + TAAR genes") + facet_wrap(~ order) + theme_bw() + theme_kz() + scale_fill_viridis()

one2twenty <- one2twenty_legend + theme(legend.position = "none")

one2four_legend <- merge_tb %>% filter(order < 5) %>% ggplot()  + geom_histogram(aes(Distance, fill = as_factor(order)), binwidth = 1) + labs(x = "Distance (Sections)", y = "OR + TAAR genes") + facet_wrap(~ order) + theme_bw() + theme_kz() + scale_fill_manual(values = c("#BE0004", "#FEC409", "#73B404", "#4B72D1"))

one2four <- one2four_legend + theme(legend.position = "none")

#SaveRectPlots(one2twenty, one2twenty_legend, one2four, one2four_legend, path = "~/Desktop/new/")
```


# AP OR plots
```{r}
names3 <- sample(rownames(merge_vnorm_raw), 3)

a1 <- c("Olfr623", "Olfr1513", "Olfr549", "Olfr676")
am1 <- c("Olfr1113", "Olfr446", "Olfr765", "Olfr355", "Olfr358", "Olfr656")
am2 <- c("Olfr148", "Olfr963", "Olfr744", "Olfr481")
m1 <- c("Olfr272", "Olfr806", "Olfr1085")
mp1 <- c("Olfr1341", "Olfr1242", "Olfr1395", "Olfr1428")
p1 <- c("Olfr1387", "Olfr1386", "Olfr193", "Olfr140")

merge_vnorm <- as_tibble(merge_vnorm_raw) %>%
    mutate(olfrname = rownames(merge_vnorm_raw)) %>%
    select(olfrname, everything()) %>%
    filter(olfrname %in% a1) %>%
    pivot_longer(names_to = "slice",
                 values_to = "normTPM",
                 cols = contains("s")) %>%
    rowwise() %>%
    mutate(slice_numeric = as.numeric(str_split(slice, "s")[[1]][2])) %>%
    ungroup() 

twopeak_plot <- merge_vnorm %>%
    ggplot() +
    geom_line(aes(slice_numeric, normTPM, color = olfrname)) +
    scale_color_startrek() +
    labs(x="AP Section", y = "Normalized TPM") +
    theme_bw() +
    theme_kz() + theme(legend.position = "right")

SaveRectPlots(anterior_2p, anterior_2p_legend, antmid_2p, antmid_2p_legend,
              antmid_2p2, antmid_2p2_legend, mid_2p, mid_2p_legend, 
              midpost_2p, midpost_2p_legend, posterior_2p, posterior_2p_legend, 
              path = "~/Desktop/heatmaps/ompdv22no1315_uni2_zero0/ap2peak/")

```


# do the same centering analysis for ML in order to define symline
```{r}
mlmiddle <- ml_ocnc
mlmergedat <- mlmerge_d <- normNormDF(m8_vnorm, m11_vnorm, 
                      m16_vnorm, 
                      calc = "median", median4 = "addmean") %>%
    SortByList(ml_ocnc)

mlmiddle$gene[1] == rownames(mlmergedat)[1]

mlmergerank <- matrix(nrow = nrow(mlmergedat), ncol = ncol(mlmergedat))
for (i in 1:nrow(mlmergedat)) {
    mlmergerank[i,] <- rank(desc(mlmergedat[i,]), ties.method = "random")
}

mlwhich1 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich2 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich3 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich4 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich5 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich6 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich7 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich8 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich9 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich10 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich11 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich12 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich13 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich14 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich15 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich16 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich17 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich18 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich19 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich20 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich21 <- vector(mode = "numeric", length = nrow(mlmergerank))
mlwhich22 <- vector(mode = "numeric", length = nrow(mlmergerank))

for (i in 1:nrow(mlmergerank)) {
    mlwhich1[i] <- which(mlmergerank[i,] == 1)
    mlwhich2[i] <- which(mlmergerank[i,] == 2)
    mlwhich3[i] <- which(mlmergerank[i,] == 3)
    mlwhich4[i] <- which(mlmergerank[i,] == 4)
    mlwhich5[i] <- which(mlmergerank[i,] == 5)
    mlwhich6[i] <- which(mlmergerank[i,] == 6)
    mlwhich7[i] <- which(mlmergerank[i,] == 7)
    mlwhich8[i] <- which(mlmergerank[i,] == 8)
    mlwhich9[i] <- which(mlmergerank[i,] == 9)
    mlwhich10[i] <- which(mlmergerank[i,] == 10)
    mlwhich11[i] <- which(mlmergerank[i,] == 11)
    mlwhich12[i] <- which(mlmergerank[i,] == 12)
    mlwhich13[i] <- which(mlmergerank[i,] == 13)
    mlwhich14[i] <- which(mlmergerank[i,] == 14)
    mlwhich15[i] <- which(mlmergerank[i,] == 15)
    mlwhich16[i] <- which(mlmergerank[i,] == 16)
    mlwhich17[i] <- which(mlmergerank[i,] == 17)
    mlwhich18[i] <- which(mlmergerank[i,] == 18)
    mlwhich19[i] <- which(mlmergerank[i,] == 19)
    mlwhich20[i] <- which(mlmergerank[i,] == 20)
    mlwhich21[i] <- which(mlmergerank[i,] == 21)
    mlwhich22[i] <- which(mlmergerank[i,] == 22)
}

mlmerge_tb <- tibble(gene = mlmiddle$gene, 
                   ml_wavg = mlmiddle$wavgs,
                   ml_rank = mlmiddle$sortrank,
                   mlplace1 = mlwhich1,
                   mlplace2 = mlwhich2,
                   mlplace3 = mlwhich3,
                   mlplace4 = mlwhich4, 
                   mlplace5 = mlwhich5,
                   mlplace6 = mlwhich6,
                   mlplace7 = mlwhich7,
                   mlplace8 = mlwhich8,
                   mlplace9 = mlwhich9,
                   mlplace10 = mlwhich10,
                   mlplace11 = mlwhich11, 
                   mlplace12 = mlwhich12,
                   mlplace13 = mlwhich13,
                   mlplace14 = mlwhich14,
                   mlplace15 = mlwhich15,
                   mlplace16 = mlwhich16, 
                   mlplace17 = mlwhich17,
                   mlplace18 = mlwhich18,
                   mlplace19 = mlwhich19,
                   mlplace20 = mlwhich20,
                   mlplace21 = mlwhich21, 
                   mlplace22 = mlwhich22) %>%
    mutate(ml_center = round(ml_wavg)) %>%
    select(gene, ml_wavg, ml_center, contains("mlplace"), ml_rank) %>%
    mutate(mlrank1 = mlplace1 - ml_center,
           mlrank2 = mlplace2 - ml_center,
           mlrank3 = mlplace3 - ml_center,
           mlrank4 = mlplace4 - ml_center,
           mlrank5 = mlplace5 - ml_center,
           mlrank6 = mlplace6 - ml_center,
           mlrank7 = mlplace7 - ml_center,
           mlrank8 = mlplace8 - ml_center,
           mlrank9 = mlplace9 - ml_center,
           mlrank10 = mlplace10 - ml_center,
           mlrank11 = mlplace11 - ml_center,
           mlrank12 = mlplace12 - ml_center,
           mlrank13 = mlplace13 - ml_center,
           mlrank14 = mlplace14 - ml_center,
           mlrank15 = mlplace15 - ml_center,
           mlrank16 = mlplace16 - ml_center,
           mlrank17 = mlplace17 - ml_center,
           mlrank18 = mlplace18 - ml_center,
           mlrank19 = mlplace19 - ml_center,
           mlrank20 = mlplace20 - ml_center,
           mlrank21 = mlplace21 - ml_center,
           mlrank22 = mlplace22 - ml_center) %>%
    pivot_longer(names_to = "Hmm", values_to = "Distance", cols = starts_with("mlrank")) %>%
    rowwise() %>% 
    mutate(order = as.numeric(str_split(Hmm, "k")[[1]][2])) %>% 
    filter(order <= 20)
```

# DORSAL-VENTRAL

```{r}
## VD normalize values
m9_tpm <- alldim_vd_tpm_cut %>% filter(rep == 9, slice <= 22) %>% select(-name, -rep, -dim, -dimrep)
m12_tpm <- alldim_vd_tpm_cut %>% filter(rep == 12, slice <= 22) %>% select(-name, -rep, -dim, -dimrep)
m14_tpm <- alldim_vd_tpm_cut %>% filter(rep == 14, slice <= 22) %>% select(-name, -rep, -dim, -dimrep)

# weights
vd_voxweights <- allmice_covars %>% filter(rep == 9) %>% select(slice, weight) %>% mutate(weightflip = 1/weight) %>% pull(weightflip)

dtvt_vd <- dtvt_norms %>% filter(rep == 9) %>% arrange(slice) %>% pull(weight)

m9w <- ompvoxnorms %>% filter(rep == 9) %>% arrange(slice) %>% pull(omprepvox)
m12w <- ompvoxnorms %>% filter(rep == 12) %>% arrange(slice) %>% pull(omprepvox)
m14w <- ompvoxnorms %>% filter(rep == 14) %>% arrange(slice) %>% pull(omprepvox)

m9_vnorm <- NormByVector(m9_tpm, m9w)
m12_vnorm <- NormByVector(m12_tpm, m12w)
m14_vnorm <- NormByVector(m14_tpm, m14w)

vd_oc <- MakeSort(m9_vnorm, m12_vnorm, m9_vnorm, m12_vnorm)
vd_ocnc <- MakeSort(m9_vnorm, m12_vnorm, m14_vnorm) 

m9_oc <- SortByList(m9_vnorm, vd_oc)
m12_oc <- SortByList(m12_vnorm, vd_oc)
m14_oc <- SortByList(m14_vnorm, vd_oc)
m9_ocnc <- SortByList(m9_vnorm, vd_ocnc)
m12_ocnc <- SortByList(m12_vnorm, vd_ocnc)
m14_ocnc <- SortByList(m14_vnorm, vd_ocnc)

h9o <- MakeBlackRedHeatmap(m9_oc)
h12o <- MakeBlackRedHeatmap(m12_oc)
h14o <- MakeBlackRedHeatmap(m14_oc)
h9d <- MakeBlackRedHeatmap(m9_ocnc)
h12d <- MakeBlackRedHeatmap(m12_ocnc)
h14d <- MakeBlackRedHeatmap(m14_ocnc)

#VD has an interesting orientation typically moving ventral (top) to dorsal (bottom) so need to flip sortrank
vd_flipsort <- vd_oc %>% 
    mutate(sortflip = min_rank(desc(sortrank))) %>% 
    select(-sortrank) %>% 
    rename("sortrank" = "sortflip")

vd9 <- m9_vnorm %>% SortByList(vd_flipsort) %>% MakeBlackRedHeatmap()
vd12 <- m12_vnorm %>% SortByList(vd_flipsort) %>% MakeBlackRedHeatmap()

vdmerge_o <- normNormDF(m9_vnorm, m12_vnorm, 
                      m14_vnorm, 
                      calc = "median", median4 = "addmean") %>%
    SortByList(vd_oc) %>%
    MakeBlackRedHeatmap()

vdmerge_d <- normNormDF(m9_vnorm, m12_vnorm, 
                      m14_vnorm, 
                      calc = "median", median4 = "addmean") %>%
    SortByList(vd_ocnc) %>%
    MakeBlackRedHeatmap()

vdfeats <- PlotFeatures(vd_flipsort, featureOut = "quadbox")
vdrtp <- PlotFeatures(vd_flipsort, featureOut = "rtp")
vdrandom <- PlotRandom(vd_flipsort)

#vdcombo
#vdfeats
```

# MEDIAL-LATERAL

## ML tpm cutoff

## avoiding m16 because it is significantly different from the other replicates

```{r}
## ML normalize values
m8_tpm <- alldim_ml_tpm_cut %>% filter(rep == 8) %>% select(-name, -rep, -dim, -dimrep)
m11_tpm <- alldim_ml_tpm_cut %>% filter(rep == 11) %>% select(-name, -rep, -dim, -dimrep)
m16_tpm <- alldim_ml_tpm_cut %>% filter(rep == 16) %>% select(-name, -rep, -dim, -dimrep)

# weights
ml_voxweights <- allmice_covars %>% filter(rep == 8) %>% select(slice, weight) %>% mutate(weightflip = 1/weight) %>% pull(weightflip)

dtvt_ml <- dtvt_norms %>% filter(rep == 8) %>% arrange(slice) %>% pull(weight)

m8w <- ompvoxnorms %>% filter(rep == 8) %>% arrange(slice) %>% pull(omprepvox)
m11w <- ompvoxnorms %>% filter(rep == 11) %>% arrange(slice) %>% pull(omprepvox)
m16w <- ompvoxnorms %>% filter(rep == 16) %>% arrange(slice) %>% pull(omprepvox)

m8_vnorm <- NormByVector(m8_tpm, m8w)
m11_vnorm <- NormByVector(m11_tpm, m11w)
m16_vnorm <- NormByVector(m16_tpm, m16w)

ml_oc <- MakeSort(m8_vnorm, m11_vnorm, m8_vnorm, m11_vnorm)
ml_ocnc <- MakeSort(m8_vnorm, m11_vnorm, m16_vnorm) 

m8_oc <- SortByList(m8_vnorm, ml_oc)
m11_oc <- SortByList(m11_vnorm, ml_oc)
m16_oc <- SortByList(m16_vnorm, ml_oc)
m8_ocnc <- SortByList(m8_vnorm, ml_ocnc)
m11_ocnc <- SortByList(m11_vnorm, ml_ocnc)
m16_ocnc <- SortByList(m16_vnorm, ml_ocnc)

h8o <- MakeBlackRedHeatmap(m8_oc)
h11o <- MakeBlackRedHeatmap(m11_oc)
h16o <- MakeBlackRedHeatmap(m16_oc)
h8d <- MakeBlackRedHeatmap(m8_ocnc)
h11d <- MakeBlackRedHeatmap(m11_ocnc)
h16d <- MakeBlackRedHeatmap(m16_ocnc)

mlmerge_o <- normNormDF(m8_vnorm, m11_vnorm, 
                      m16_vnorm, 
                      calc = "median", median4 = "addmean") %>%
    SortByList(ml_oc) %>%
    MakeBlackRedHeatmap()

mlmerge_d <- normNormDF(m8_vnorm, m11_vnorm, 
                      m16_vnorm, 
                      calc = "median", median4 = "addmean") %>%
    SortByList(ml_ocnc) %>%
    MakeBlackRedHeatmap()

mlfeats <- PlotFeatures(ml_oc, featureOut = "quadbox")
mlrtp <- PlotFeatures(ml_oc, featureOut = "rtp")
mlrandom <- PlotRandom(ml_oc)

#mlcombo
#mlfeats
```


# make new info table
```{r}
subinfo <- info %>% select(olfrname:Zolfr_Momb, protlength)
ap_info <- oc_sort %>% rename(olfrname = gene, ap_wavg = wavgs, ap_rank = sortrank)
vd_info <- vd_oc %>% rename(olfrname = gene, vd_wavg = wavgs, vd_rank = sortrank)
ml_info <- ml_oc %>% rename(olfrname = gene, ml_wavg = wavgs, ml_rank = sortrank)
newinfo <- subinfo %>% left_join(ap_info, by ="olfrname") %>% left_join(vd_info, by = "olfrname") %>% left_join(ml_info, by = "olfrname") 
filterinfo <- newinfo %>%
    mutate(zeroRep = ifelse(olfrname %in% zero_inrep_ORs, T, F),
           ectopic = ifelse(olfrname %in% ectopic_ORs, T, F),
           below1tpm = ifelse(olfrname %in% below1mingoodtho, T, F),
           omp1uni = ifelse(olfrname %in% uniform_ORs, T, F)) %>%
    rowwise() %>%
    mutate(filterFail = max(zeroRep, ectopic, below1tpm, omp1uni))

#check for OR/OR-ps duplicates
newinfo %>% rowwise() %>% mutate(baseid = str_split(olfrname, "-")[[1]][1]) %>% ungroup %>% mutate(isPS = str_detect(olfrname, "-ps")) %>% select(olfrname, baseid, isPS) %>% group_by(baseid) %>% count() %>% arrange(desc(n))
```


# Do mombaerts ORs that fall out of picture overlap (Mombcomp_picalign.odp) have 2 AP peaks?
```{r}
#Olfr15 aka MOR256-17 and Olfr1507 aka MOR28 had medial gloms that did not overlap in 
labeled_ORs <- c("Olfr1377", "Olfr881", "Olfr16", "Olfr17", 
                 "Olfr15", "Olfr155", "Olfr160", "Olfr1507")
labelAP <- SubsetAllAP(labeled_ORs)
labelMLVD <- SubsetAllMLVD(labeled_ORs)

sak_tib <- tibble(olfrname = c("Olfr1440", "Olfr156", "Olfr155", "Olfr119", 
                               "Olfr120", "Olfr402", "Olfr1497", "Olfr308", 
                               "Olfr411", "Olfr523", "Olfr16", "Olfr73", 
                               "Olfr17", "Olfr536", "Olfr1195", "Olfr170", 
                               "Olfr1226", "Olfr1507", "Olfr1193", "Olfr1512", 
                               "Olfr449", "Olfr978", "Olfr725", "Olfr20", 
                               "Olfr164", "Olfr160", "Olfr727", "Olfr390", 
                               "Olfr943", "Olfr165", "Olfr15", "Olfr1333"),
                  group = c(rep("Anterior", times = 10),
                            rep("Middle", times = 3),
                            rep("Posterior", times = 19)),
                  rank = 1:32) 

sak_am <- sak_tib %>% 
    filter(group != "Posterior") %>%
    pull(olfrname)

sak_p <- sak_tib %>% 
    filter(group == "Posterior") %>%
    pull(olfrname)

sakAnteriorMiddle_ap <- SubsetAllAP(sak_am)
sakPosterior_ap <- SubsetAllAP(sak_p)
```

# Save plots
```{r, eval=F}
SaveHeatmaps(ap4, ap6, ap7, ap10,
             vd9, vd12, ml8, ml11,
             oc_medianmerge_addmean, oc_medianmerge_add0, oc_medianmerge_use4, 
             vdmerge, mlmerge,
             labelAP, labelMLVD, sakAnteriorMiddle_ap, sakPosterior_ap,
             path = "~/Desktop/figs_obmap/heatmaps/")


SaveHeatmaps(h4o, h6o, h7o, h10o, 
             h9o, h12o, h14o, h9d, h12d, h14d, 
             h8o, h11o, h16o, h8d, h11d, h16d, 
             apmerge, vdmerge_o, mlmerge_o, 
             vdmerge_d, mlmerge_d, 
             labelAP, labelMLVD, 
             sakAnteriorMiddle_ap, sakPosterior_ap, 
             path = "~/Desktop/heatmaps/ompdv22no1315_uni2_zero0/")

SaveSquarePlots(apfeats,aprandom,
                vdfeats,vdrandom,
                mlfeats,mlrandom,
                path = "~/Desktop/heatmaps/ompdv22no1315_uni2_zero0/")
```

# Does DV wavg relate to OE DV features
```{r}
info_dvsub <- info %>% 
    select(olfrname, class:tz_vdnona, DPT_index:Zolfr_Momb, 
           vd_wavg, vd_rank, zeroRep:filterFail) %>%
    mutate(wavg_bin = round(2*vd_wavg)/2,
           tz_bin = round(2*tz_val)/2,
           Zolfr_bin = round(2*Zolfr_Momb)/2,
           dumb_bin = round(vd_wavg))

tanzap_1bin_legend <- info_dvsub %>% 
    filter(!is.na(dumb_bin)) %>%
    group_by(dumb_bin) %>%
    summarise(Tan2018 = mean(tz_bin, na.rm=T),
              Zapiec2020 = mean(Zolfr_Momb, na.rm=T)) %>%
    pivot_longer(names_to = "Reference", values_to = "mean_index", 
                 cols = c(Tan2018, Zapiec2020)) %>%
    ggplot() +
    geom_line(aes(dumb_bin, mean_index, color = Reference), size = 2) +
    scale_color_manual(values = c("black", "red")) + 
    labs(x = "Ventral-Dorsal mean position", y = "Mean Index Value") +
    theme_bw() +
    theme_kz()

tanzap_1bin <- info_dvsub %>% 
    filter(!is.na(dumb_bin)) %>%
    group_by(dumb_bin) %>%
    summarise(Tan2018 = mean(tz_bin, na.rm=T),
              Zapiec2020 = mean(Zolfr_Momb, na.rm=T)) %>%
    pivot_longer(names_to = "Reference", values_to = "mean_index", 
                 cols = c(Tan2018, Zapiec2020)) %>%
    ggplot() +
    geom_line(aes(dumb_bin, mean_index, color = Reference), size = 2) +
    scale_color_manual(values = c("black", "red")) + 
    labs(x = "Ventral-Dorsal mean position", y = "Mean Index Value") +
    theme_bw() +
    theme_kz() +
    theme(legend.position = "none")

tanzap_0.5bin <- info_dvsub %>% 
    filter(!is.na(wavg_bin)) %>%
    group_by(wavg_bin) %>%
    summarise(Tan2018 = mean(tz_bin, na.rm=T),
              Zapiec2020 = mean(Zolfr_Momb, na.rm=T)) %>%
    pivot_longer(names_to = "Reference", values_to = "mean_index", 
                 cols = c(Tan2018, Zapiec2020)) %>%
    ggplot() +
    geom_line(aes(wavg_bin, mean_index, color = Reference), size = 2) +
    scale_color_manual(values = c("black", "red")) + 
    labs(x = "Ventral-Dorsal mean position", y = "Mean Index Value") +
    theme_bw() +
    theme_kz() +
    theme(legend.position = "none")

#SaveRectPlots(tanzap_1bin, tanzap_1bin_legend, tanzap_0.5bin, path = "~/Desktop/heatmaps/ompdv22no1315_uni2_zero0/")

```


# matrix similarity tests

try sorting with kmeans clustering

```{r}
voxsort_cor <- MultiSpearMatrix(m4_voxsort, m6_voxsort, m7_voxsort, m10_voxsort)
#heatmaply_cor(voxsort_cor, Rowv=F, Colv=F)

km <- kmeans(scale(m4_voxsort), 23, iter.max = 1000)
km_sort <- tibble("gene" = names(km$cluster), "sortrank" = km$cluster, wavgs = 2)
m4_kmsort <- SortByList(m4_voxsort, km_sort)
#heatmaply_cor(m4_kmsort, Rowv=F, Colv=F)
#need to add km_sort as well as voxsort and compare, perhaps possible to determine order of km clusters from AtoP
```

# Which ORs covary?

PCA, tsne, dimred plots For each OR, create a vector holding meanposition for all replicates and all dimensions Calculate all pairwise correlations for these vectors and determine a cutoff for covariance, can also compare lowest distance by subtracting or something

```{r}
#for each mouse, for each row
vnorms <- list(m4_vnorm, m6_vnorm, m7_vnorm, m10_vnorm,
            m9_vnorm, m12_vnorm, m14_vnorm,
            m8_vnorm, m11_vnorm, m16_vnorm)

#problem is vnorms are different lengths, may need to use a different 
meanpos_mtx <- matrix(ncol = length(vnorms), nrow = nrow(vnorms[[1]]))
for (i in 1:length(vnorms)) {
    df_norm <- vnorms[[i]]
    secs <- c(1:ncol(vnorms[[i]]))
    wavgs <- vector(mode = "numeric", length = nrow(df_norm))
    for (j in 1:nrow(df_norm)) {
        vals <- df_norm[j,]
        sumvals <- sum(vals)
        prods <- vector(mode = "numeric", length = length(vals))
        for (k in 1:length(vals)) {
            prods[k] <- vals[k] * secs[k]
        }
        wavgs[j] <- sum(prods)/sumvals
    }
    meanpos_mtx[,i] <- wavgs
}

rownames(meanpos_mtx) <- rownames(m4_vnorm)
colnames(meanpos_mtx) <- c("m4_AP", "m6_AP", "m7_AP", "m10_AP",
                           "m9_VD", "m12_VD", "m14_VD", "m8_ML", "m11_ML", "m16_ML")

lancet <- read_csv("~/Desktop/obmap/r_analysis/data/make_TPMmtx/lancet_mouseORnames.csv") %>%
    rename(olfrname = Olfrname) %>%
    mutate(pseudo = as.logical(Pseudo)) %>%
    select(olfrname, Symbol, pseudo) %>%
    rowwise() %>%
    mutate(geneup = toupper(Symbol),
           family = as.numeric(str_match(geneup, "\\d+")[[1]]),
           subfam = str_match(str_match(geneup, "\\d[A-Z]+\\d"), "[A-Z]+")[[1]]) %>%
    ungroup() %>%
    select(olfrname, family, subfam)

meanpos_tb <- as_tibble(meanpos_mtx) %>% 
    mutate(olfrname = rownames(meanpos_mtx)) %>%
    select(olfrname, everything()) %>%
    left_join(babyinfo, by = "olfrname") %>%
    left_join(newinfo, by = "olfrname") %>%
    left_join(lancet, by = "olfrname") #%>% drop_na()

write_csv(meanpos_tb, "~/Desktop/obmap/r_analysis/data/heatmaps/meanpos_ompdv22no1315_210429.csv")

#heatmaply_cor(meanpos_mtx)

meanpos_cor <- cor(t(meanpos_mtx))
meanpos_cov <- cov(t(meanpos_mtx))

#make heatmaply_cor with class/family dendros and labels
meanpos_cor_sc <- cbind(meanpos_cor, meanpos_tb$class)
heatmaply_cor(meanpos_cor_sc[,-ncol(meanpos_cor_sc)],
              Rowv = corinfo$class, Colv = "Rowv",
              dendrogram = "none",
              row_side_colors = meanpos_cor_sc[,ncol(meanpos_cor_sc)])

#if still sucks, plot ORs on umap (avoids another fucking heatmap in my paper) and color by class and fam
```


# Are ORs with similar sequence in similar positions?
## Use pairwise alignments to determine the X most similar ORs to a given OR
```{r, eval=F}
library(tidyverse)
library(seqinr)
library(Biostrings)

data("BLOSUM62")
mouseor <- read.fasta("~/Desktop/obmap/r_analysis/data/heatmaps//kz_mouseor.fasta", 
                      as.string = T, set.attributes = F, seqtype = "AA")
#dotPlot(mouseor[[1]], mouseor[[2]]) #need to import fasta with as.string=F

orlengths <- vector(mode = "numeric", length = length(mouseor))
ornames <- vector(mode = "character", length = length(mouseor))
for (i in 1:length(mouseor)) {
    orlengths[i] <- nchar(mouseor[[i]])
    ornames[i] <- names(mouseor)[i]
}
mouseordata <- tibble(olfrname = ornames, protlength = orlengths)

test <- pairwiseAlignment(mouseor[[1]], mouseor[[2]], 
                          substitutionMatrix = "BLOSUM62")

#make a mtrix holding a pairwise alignment score for each pair of OR seqs
seqsim_score <- matrix(nrow = length(mouseor), ncol = length(mouseor))
for (i in 1:length(mouseor)) {
    for (j in i:length(mouseor)) {#submtx and gapscores similar to default blastp
        seqsim_score[i,j] <- pairwiseAlignment(mouseor[[i]], mouseor[[j]], 
                                               substitutionMatrix = "BLOSUM62",
                                               scoreOnly = T,
                                               gapOpening = 11,
                                               gapExtension = 1) 
        seqsim_score[j,i] <- seqsim_score[i,j]
    } #endif
} #endfor
} #endfor
colnames(seqsim_score) <- names(mouseor)
rownames(seqsim_score) <- names(mouseor)

#saveRDS(seqsim_score, "~/Desktop/obmap/r_analysis/heatmaps/output/seqsim_B62.RDS")
seqsim_score <- readRDS("~/Desktop/obmap/r_analysis/data/heatmaps/seqsim_B62.RDS")

#make a matrix for which scores in each column are ranked
#likely introduces some bias based on seq length since these are raw scores
seqsim_rank <- matrix(nrow = nrow(seqsim_score), ncol = ncol(seqsim_score))
for (i in 1:ncol(seqsim_score)) {
    seqsim_rank[,i] <- rank(dplyr::desc(seqsim_score[,i]), ties.method = "random")
} #endfor
colnames(seqsim_rank) <- names(mouseor)
rownames(seqsim_rank) <- names(mouseor)

#create a matrix where the 1st row holds the olfr name of the 1st ranked score
seqsim_names <- matrix(nrow = nrow(seqsim_rank), ncol = ncol(seqsim_rank))
for (i in 1:ncol(seqsim_rank)) {
    for (j in 1:nrow(seqsim_rank)) {
        seqsim_names[j,i] <- rownames(seqsim_rank)[which(seqsim_rank[,i] == j)]
    } #endfor
} #endfor
colnames(seqsim_names) <- names(mouseor)
rownames(seqsim_names) <- 1:nrow(seqsim_names)

#saveRDS(seqsim_names, "~/Desktop/obmap/r_analysis/heatmaps/output/seqsim_ranknames.RDS")

mouse_names <- colnames(allmice_final)[which(str_detect(colnames(allmice_final), "Olfr"))]
length(mouse_names)
length(which(mouse_names %in% names(mouseor)))

`%notin%` <- Negate(`%in%`)
mouse_names[which(mouse_names %notin% names(mouseor))]
#Olfr779 is a pseudogene and no well annotated protein sequence can be found online
#could resolve by taking CDS coordinates from gencode release and converting DNA to protein


# Do closely related ORs have similar expression patterns?
seqsim_names <- readRDS("~/Desktop/obmap/r_analysis/data/heatmaps/seqsim_ranknames.RDS")
takethismany <-  25
numsim <- 6
rpick <- sample(1:ncol(seqsim_names), size = takethismany)

aptrunk <- vector("list", length = length(rpick))
mlvdtrunk <- vector("list", length = length(rpick))
nametrunk <- vector("list", length = length(rpick))
for (i in 1:length(rpick)) {
    col_olfr <- colnames(seqsim_names)[rpick[i]]
    names <- c(col_olfr, seqsim_names[1:numsim, rpick[i]])
    
    aptrunk[[i]] <- SubsetAllAP(names)
    mlvdtrunk[[i]] <- SubsetAllMLVD(names)
    nametrunk[[i]] <- SubsetBLRH4(oc_vnorms[[1]],
                                  oc_vnorms[[2]],
                                  oc_vnorms[[3]],
                                  oc_vnorms[[4]],
                                  names, out = "names", sort = F)
}

aprandom <- vector("list", length = length(rpick))
mlvdrandom <- vector("list", length = length(rpick))
namerandom <- vector("list", length = length(rpick))
for (i in 1:length(rpick)) {
    col_olfr <- colnames(seqsim_names)[rpick[i]]
    random <- sample(1:nrow(seqsim_names), numsim)
    names <- c(col_olfr, seqsim_names[sample(random, numsim), rpick[i]])
    
    aprandom[[i]] <- SubsetAllAP(names)
    mlvdrandom[[i]] <- SubsetAllMLVD(names)
    namerandom[[i]] <-  SubsetBLRH4(oc_vnorms[[1]],
                                  oc_vnorms[[2]],
                                  oc_vnorms[[3]],
                                  oc_vnorms[[4]],
                                  names, out = "names", sort = F)
}

# check more comprehensively
## For each OR, compute wavg position difference for increasing numbers of similar ORs
seqsim_names <- readRDS("~/Desktop/obmap/r_analysis/data/heatmaps/seqsim_ranknames.RDS")

#determine increment
divisors <- vector(mode = "numeric")
obs <- nrow(oc_sort)

for (i in 1:round(obs/2)) {
    if (obs %% i == 0) {
        divisors <- c(divisors, i)
    }
}
divisors

increment <- divisors[2]

simdist_colnames <- c("olfrname", "increment", "ap_dist", "ml_dist", "vd_dist", "dist3d", "totdist")
simdist <- matrix(nrow = (obs/increment)*obs, ncol = length(simdist_colnames))
for (i in 1:nrow(oc_sort)) {
    #determine position of reference OR
    col_olfr <- oc_sort %>% filter(sortrank == i) %>% pull(gene)
    ap_col <- oc_sort %>% filter(gene == col_olfr) %>% pull(wavgs)
    ml_col <- ml_oc %>% filter(gene == col_olfr) %>% pull(wavgs)
    vd_col <- vd_oc %>% filter(gene == col_olfr) %>% pull(wavgs)
    
    #determine position of increasingly larger groups of similar ORs
    for (j in 1:(obs/increment)) {
        group_olfrs <- seqsim_names[1:(j*increment), which(colnames(seqsim_names) == col_olfr)]
        ap_group <- oc_sort %>% filter(gene %in% group_olfrs) %>% pull(wavgs) %>% mean(na.rm=T)
        ml_group <- ml_oc %>% filter(gene %in% group_olfrs) %>% pull(wavgs) %>% mean(na.rm=T)
        vd_group <- vd_oc %>% filter(gene %in% group_olfrs) %>% pull(wavgs) %>% mean(na.rm=T)
        
        ap_dif <- round(abs(ap_group - ap_col), digits = 2)
        ml_dif <- round(abs(ml_group - ml_col), digits = 2)
        vd_dif <- round(abs(vd_group - vd_col), digits = 2)
        
        dif_3d <- round(sqrt(ap_dif^2 + ml_dif^2 + vd_dif^2), digits = 2)
        totdist <- ap_dif + ml_dif + vd_dif
        
        simdist[(i-1) * (obs/increment) + j,] <- c(col_olfr, j, ap_dif, ml_dif, vd_dif, dif_3d, totdist)
    } #endforj
    if(i %% 25 == 0) {print(i)}
} #endfori

colnames(simdist) <- simdist_colnames

infoclassonly <- info %>% select(olfrname, class)

simdist <- as_tibble(simdist) %>% 
    left_join(infoclassonly, by = "olfrname")

simdist$increment %<>% as.integer
simdist$ap_dist %<>% as.numeric
simdist$ml_dist %<>% as.numeric
simdist$vd_dist %<>% as.numeric
simdist$dist3d %<>% as.numeric
simdist$totdist %<>% as.numeric

saveRDS(simdist, "~/Desktop/obmap/r_analysis/data/heatmaps/seqsim_ompdv22no1315_wavgdist.RDS")

simdist <- readRDS("~/Desktop/obmap/r_analysis/data/heatmaps/seqsim_ompdv22no1315_wavgdist.RDS") %>%
    filter(!is.na(ap_dist)) %>%
    filter(!is.na(class))

simdist_sum <- simdist %>% 
    filter(class == 1) %>% 
    group_by(increment) %>% 
    summarise(m_ap = mean(ap_dist, na.rm=T),
              m_ml = mean(ml_dist, na.rm=T),
              m_vd = mean(vd_dist, na.rm=T),
              m_3d = mean(dist3d, na.rm=T))

ggplot(simdist %>% filter(class == 1)) +
    geom_line(aes(increment, ap_dist, group = olfrname, color = olfrname)) +
    geom_point(data = simdist_sum, aes(increment, m_ap)) +
    theme_cowplot() +
    theme(legend.position = "none") +
    ggtitle("Class 1 ORs - ap")

simdist %>% filter(increment <= 10 & class == 1) %>% ggplot() + geom_boxplot(aes(increment, ap_dist, group = increment)) + geom_point(data = simdist_sum %>% filter(increment <= 10), aes(increment, m_ap), color = "Red", size = 3)

# ggsave(plot = simdistplot,
#        "~/Desktop/obmap/r_analysis/heatmaps/output/seqsim_allOR_3d.png",
#        width = 8,
#        height = 6)


# score based distance calcs
simscore <- readRDS("~/Desktop/obmap/r_analysis/data/heatmaps/seqsim_B62.RDS")

simscore_dist_names <- c("olfr1", "olfr2", "score", "ap_dist", "ml_dist", "vd_dist", "dist_3d", "counter")

simscore_dist <- matrix(nrow = ((nrow(simscore)^2 + nrow(simscore))/2), 
                        ncol = length(simscore_dist_names))
print(dim(simscore_dist))
counter <- 1

#calculate dist for 1/2 of the pairwise score mtx
for (j in 1:ncol(simscore)) {
    for (i in j:nrow(simscore)) {
        #how far along are we?
        if (j %% 50 == 0 & i == nrow(simscore)) {
            print(j)
        }
        # 
        # #deal with final row being out of bounds
        # if (i > nrow(simscore)) {
        #   print("End")
        #   break
        # }
        
        if (simscore[i,j] >= 1) {
            if (i == j) {
                simscore_dist[counter,] <- c(colnames(simscore)[i], 
                                             rownames(simscore)[j], 
                                             simscore[i,j], 0,0,0,0, counter)
                counter <- counter + 1
            } else {
                olfrs <- c(colnames(simscore)[j], rownames(simscore)[i])
                
                ap_wavgs <- oc_sort %>%
                    filter(gene %in% olfrs) %>%
                    pull(wavgs)
                ap_dist <- round(abs(ap_wavgs[1] - ap_wavgs[2]), digits=2)
                
                ml_wavgs <- ml_oc %>%
                    filter(gene %in% olfrs) %>%
                    pull(wavgs)
                ml_dist <- round(abs(ml_wavgs[1] - ml_wavgs[2]), digits=2)
                
                vd_wavgs <- vd_flipsort %>%
                    filter(gene %in% olfrs) %>%
                    pull(wavgs)
                vd_dist <- round(abs(vd_wavgs[1] - vd_wavgs[2]), digits=2)
                
                dist_3d <- round(sqrt(ap_dist^2 + ml_dist^2 + vd_dist^2), digits = 2)
                
                vals <- c(olfrs, simscore[i,j], ap_dist, ml_dist, vd_dist, dist_3d, counter)
                simscore_dist[counter,] <- vals
                counter <- counter + 1
            } #endif
        } #endif
    } #endfori
} #endforj

colnames(simscore_dist) <- simscore_dist_names

simscore_dist <- as_tibble(simscore_dist) %>% filter(!is.na(ap_dist))

simscore_dist$score %<>% as.numeric
simscore_dist$ap_dist %<>% as.numeric
simscore_dist$ml_dist %<>% as.numeric
simscore_dist$vd_dist %<>% as.numeric
simscore_dist$dist_3d %<>% as.numeric
simscore_dist$counter %<>% as.numeric

infoclassonly <- info %>% select(olfrname, class)

#define classes for both olfrs
simscore_dist <- simscore_dist  %>%
    dplyr::rename(olfrname = olfr1) %>%
    left_join(infoclassonly) %>%
    dplyr::rename(class1 = class, olfr1 = olfrname, olfrname = olfr2) %>%
    left_join(infoclassonly) %>%
    dplyr::rename(class2 = class, olfr2 = olfrname)

#flip olfr1 and olfr2 to make all relationships
simscore_distflip <- simscore_dist %>% 
    dplyr::rename(olfr3 = olfr1, olfr1 = olfr2) %>%
    dplyr::rename(olfr2 = olfr3) %>%
    select(olfr1, olfr2, everything())

simscore_distall <- bind_rows(simscore_dist, simscore_distflip) %>%
    select(-counter) %>%
    arrange(olfr1, desc(score))

saveRDS(simscore_distall, "~/Desktop/obmap/r_analysis/data/heatmaps/seqsim_ompdv22no1315_scoredist.RDS")
```


```{r}
info1 <- read_csv("~/Desktop/info_210430.csv") %>% 
    select(olfrname, oe_region, tz_vd, protlength) %>%
    rename(olfr1 = olfrname, oe1 = oe_region, tz1 = tz_vd, length1 = protlength) %>%
    mutate(dv1 = ifelse(is.na(tz1), oe1, tz1))


info2 <- read_csv("~/Desktop/info_210430.csv") %>% 
    select(olfrname, oe_region, tz_vd, protlength) %>%
    rename(olfr2 = olfrname, oe2 = oe_region, tz2 = tz_vd, length2 = protlength) %>%
    mutate(dv2 = ifelse(is.na(tz2), oe2, tz2))

simscore_dist <- readRDS("~/Desktop/obmap/r_analysis/data/heatmaps/seqsim_ompdv22no1315_scoredist.RDS") %>% 
    mutate(dupe = ifelse(olfr1 == olfr2, T, F)) %>%
    left_join(info1, by = "olfr1") %>%
    left_join(info2, by = "olfr2") %>%
    rowwise() %>%
    mutate(score_length = score/mean(c(length1, length2), na.rm=T)) %>%
    ungroup() %>%
    group_by(olfr1) %>%
    mutate(avg_dist = (ap_dist + ml_dist + vd_dist)/3) %>%
    ungroup() %>%
    filter(dupe == F) %>%
    mutate(score_binraw = ifelse(score < 1025, 
                                 "Below60", ifelse(score > 1325, 
                                                   "Above80", "Between60_80")),
           score_bin = factor(score_binraw, levels = c("Below60", "Between60_80", "Above80"))) %>%
    select(-score_binraw)

TestTopBot <- function(class = 2, dv = "Dorsal", testX = 50, out = "box") {
    tester <- simscore_dist %>%
        mutate(filterFail1 = ifelse(olfr1 %in% filter_ORs, T, F),
               filterFail2 = ifelse(olfr2 %in% filter_ORs, T, F)) %>%
        filter(filterFail1 == F & filterFail2 == F) %>%
        filter(class1 == class,
               class2 == class,
               dv1 == dv,
               dv2 == dv) %>%
        group_by(olfr1) %>%
        mutate(o1_toprank = min_rank(desc(score_length)),
               o1_botrank = min_rank(score_length),
               o1_topX = ifelse(o1_toprank <= testX, T, F),
               o1_botX = ifelse(o1_botrank <= testX, T, F)) %>%
        ungroup() %>%
        filter(o1_topX == T | o1_botX == T)
    
    top_bot_dim_histo <- tester %>% 
        group_by(olfr1, o1_topX) %>%
        summarise(meanAP = mean(ap_dist),
                  meanDV = mean(vd_dist),
                  meanML = mean(ml_dist)) %>% 
        pivot_longer(names_to = "dim", values_to = "dist", cols = c(meanAP, meanDV, meanML)) %>%
        mutate(renamed = ifelse(o1_topX == T, 
                                paste(testX, "Most Similar ORs"), 
                                paste(testX, "Least Similar ORs"))) %>%
        ggplot() + 
        geom_histogram(aes(dist, fill = renamed)) + 
        facet_grid(renamed ~ dim) +
        scale_fill_manual(values = c("#010000", "#ff0000")) +
        labs(x = "Distance between ORs (sections)", 
             y = paste("Number of Class", class, dv, "genes")) +
        theme_bw() +
        theme_kz() +
        theme(panel.grid.minor = element_blank()) 
    
    top_bot_dim_box <- tester %>% 
        group_by(olfr1, o1_topX) %>%
        summarise(meanAP = mean(ap_dist),
                  meanDV = mean(vd_dist),
                  meanML = mean(ml_dist)) %>% 
        pivot_longer(names_to = "dim", values_to = "dist", cols = c(meanAP, meanDV, meanML)) %>%
        mutate(renamed = ifelse(o1_topX == T, 
                                paste(testX, "Most Similar ORs"), 
                                paste(testX, "Least Similar ORs"))) %>%
        ggplot() + 
        geom_boxplot(aes(dim, dist, color = renamed), 
                     lwd = 1.5, outlier.shape = NA, position = position_dodge()) +
        geom_point(aes(dim, dist, color = renamed, fill = renamed), 
                    position = position_jitterdodge(jitter.width = 0.2), alpha = 0.3) +
        scale_color_manual(values = c("#010000", "#ff0000")) +
        labs(y = "Distance between ORs (sections)", 
             x = "Dimension") +
        theme_bw() +
        theme_kz() +
        theme(panel.grid.minor = element_blank())
    
    byOlfr <- tester %>% 
        group_by(olfr1, o1_topX) %>%
        summarise(meanAP = mean(ap_dist),
                  meanDV = mean(vd_dist),
                  meanML = mean(ml_dist))  %>% 
        pivot_wider(names_from = o1_topX, values_from = c(meanAP, meanML, meanDV)) %>%
        mutate(meanAP_dif = meanAP_FALSE - meanAP_TRUE,
               meanDV_dif = meanDV_FALSE - meanDV_TRUE,
               meanML_dif = meanML_FALSE - meanML_TRUE,
               mean3_dif = mean(c(meanAP_dif, meanDV_dif, meanML_dif)),
               betterAP = ifelse(meanAP_dif > 0, T, F),
               betterDV = ifelse(meanDV_dif > 0, T, F),
               betterML = ifelse(meanML_dif > 0 , T, F),
               bettermean3 = ifelse(mean3_dif > 0, T, F),
               betterAll3 = betterAP*betterDV*betterML) %>%
        ungroup()
    
    or_apdv <- ggplot(byOlfr) + 
        geom_vline(xintercept = 0, color = "red", linetype = 2) + 
        geom_hline(yintercept = 0, color = "red", linetype = 2) +
        geom_point(aes(meanAP_dif, meanDV_dif)) + 
        labs(x = "Improvement in mean AP distance", y = "Improvement in mean DV distance") +
        theme_bw() +
        theme_kz() +
        theme(panel.grid.minor = element_blank())
    
    or_apml <- ggplot(byOlfr) + 
        geom_vline(xintercept = 0, color = "red", linetype = 2) + 
        geom_hline(yintercept = 0, color = "red", linetype = 2) +
        geom_point(aes(meanAP_dif, meanML_dif)) + 
        labs(x = "Improvement in mean AP distance", y = "Improvement in mean ML distance") +
        theme_bw() +
        theme_kz() +
        theme(panel.grid.minor = element_blank())
    
    or_dvml <- ggplot(byOlfr) + 
        geom_vline(xintercept = 0, color = "red", linetype = 2) + 
        geom_hline(yintercept = 0, color = "red", linetype = 2) +
        geom_point(aes(meanDV_dif, meanML_dif)) + 
        labs(x = "Improvement in mean DV distance", y = "Improvement in mean ML distance") +
        theme_bw() +
        theme_kz() +
        theme(panel.grid.minor = element_blank())
    
    or_better <- byOlfr %>% 
        pivot_longer(names_to = "dim", values_to = "improved", 
                     cols = c(betterAP, betterDV, betterML)) %>% 
        group_by(dim, improved) %>% 
        count() %>% 
        ggplot() + 
        geom_bar(aes(dim, n, fill = improved), 
                 stat = "identity", position = position_dodge()) +
        scale_fill_manual(values = c("#010000", "#ff0000")) +
        labs(x = "Dimension", 
             y = paste("Number of Class", class, dv, "genes")) +
        theme_bw() + theme_kz() 
    
    if (str_detect(tolower(out), "box")) {
        return(top_bot_dim_box)
    } else if (str_detect(tolower(out), "histo")) {
        return(top_bot_dim_histo)
    } else if (str_detect(tolower(out), "apdv")) {
        return(or_apdv)
    } else if (str_detect(tolower(out), "apml")) {
        return(or_apml)
    } else if (str_detect(tolower(out), "dvml")) {
        return(or_dvml)
    } else if (str_detect(tolower(out), "orbetter")) {
        return(or_better)
    } else {
        return(top_bot_dim_box)
    } #endif
} #end TestTopBot

c2d_100_box <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "box") +
    theme(legend.position = "none")
c2d_100_histo <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "histo") +
    theme(legend.position = "none")
c2d_100_apdv <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "apdv") +
    theme(legend.position = "none")
c2d_100_apml <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "apml") +
    theme(legend.position = "none")
c2d_100_dvml <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "dvml") +
    theme(legend.position = "none")
c2d_100_orbetter <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "orbetter") +
    theme(legend.position = "none")

c2v_100_box <- TestTopBot(class = 2, dv = "Ventral", testX = 100, out = "box") +
    theme(legend.position = "none")
c2v_100_histo <- TestTopBot(class = 2, dv = "Ventral", testX = 100, out = "histo") +
    theme(legend.position = "none")
c2v_100_apdv <- TestTopBot(class = 2, dv = "Ventral", testX = 100, out = "apdv") +
    theme(legend.position = "none")
c2v_100_apml <- TestTopBot(class = 2, dv = "Ventral", testX = 100, out = "apml") +
    theme(legend.position = "none")
c2v_100_dvml <- TestTopBot(class = 2, dv = "Ventral", testX = 100, out = "dvml") +
    theme(legend.position = "none")
c2v_100_orbetter <- TestTopBot(class = 2, dv = "Ventral", testX = 100, out = "orbetter") +
    theme(legend.position = "none")

c1d_50_box <- TestTopBot(class = 1, dv = "Dorsal", testX = 50, out = "box") +
    theme(legend.position = "none")
c1d_50_histo <- TestTopBot(class = 1, dv = "Dorsal", testX = 50, out = "histo") +
    theme(legend.position = "none")
c1d_50_apdv <- TestTopBot(class = 1, dv = "Dorsal", testX = 50, out = "apdv") +
    theme(legend.position = "none")
c1d_50_apml <- TestTopBot(class = 1, dv = "Dorsal", testX = 50, out = "apml") +
    theme(legend.position = "none")
c1d_50_dvml <- TestTopBot(class = 1, dv = "Dorsal", testX = 50, out = "dvml") +
    theme(legend.position = "none")
c1d_50_orbetter <- TestTopBot(class = 1, dv = "Dorsal", testX = 50, out = "orbetter") +
    theme(legend.position = "none")

legend_box <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "box")
legend_histo <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "histo")
legend_orbetter <- TestTopBot(class = 2, dv = "Dorsal", testX = 100, out = "orbetter") 

#SaveRectPlots(legend_box, legend_histo, legend_orbetter,c1d_50_box, c1d_50_histo, c1d_50_apdv, c1d_50_apml, c1d_50_dvml, c1d_50_orbetter, c2d_100_box, c2d_100_histo, c2d_100_apdv, c2d_100_apml, c2d_100_dvml, c2d_100_orbetter, c2v_100_box, c2v_100_histo, c2v_100_apdv, c2v_100_apml, c2v_100_dvml, c2v_100_orbetter, path = "~/Desktop/heatmaps/seqsim/ompdv22no1315")
    

# Curve for score-percentID
#https://web.expasy.org/sim/
#score 1600 is ~100%, same-same
#score 1500 is ~93%, Olfr1209-Olfr1199
#score 1350 is ~81%, Olfr791-Olfr769
#score 1200 is ~71%, Olfr1204-Olfr1259
#score 1050 is ~62%, Olfr816-Olfr771
#score 900 is ~57%, Olfr974-Olfr921
#score 750 is ~48%, Olfr557-Olfr67
#score 600 is ~41%, Olfr323-Olfr172
#score 450 is ~37%, Olfr523-Olfr726
#score 300 is ~28%, Olfr1349-Olfr667
#score 149 is ~25%, Olfr94-Olfr243

seqident <- tibble(score = c(1600, 1500, 1350, 1200, 1050, 900, 750, 600, 450, 300, 149),
                   pid = c(100, 93, 81, 71, 62, 57, 48, 41, 37, 28, 25))

ggplot(seqident) + geom_line(aes(score, pid)) + ggtitle("Relationship between Score and %identity")

ggplot(simscore_dist, aes(score, ap_dist)) + geom_point(alpha = 0.1)

Simscore_DVPlot <- function(class = 2, dv = "Dorsal", dim = "AP") {
    plot_dat <- simscore_dist %>% filter(class1 == class, 
                                         class2 == class, 
                                         oe1 == dv,
                                         oe2 == dv,
                                         dupe == F)
    
    title <- paste0(dim, " Class", class, " ", dv)
    
    if (str_detect(tolower(dim), "ap")) {
        ggplot(plot_dat, aes(score, ap_dist)) +
            geom_point(alpha = 0.1) +
            geom_smooth(method = "gam") +
            ggtitle(title)
    } else if (str_detect(tolower(dim), "ml")) {
        ggplot(plot_dat, aes(score, ml_dist)) +
            geom_point(alpha = 0.1) +
            geom_smooth(method = "gam") +
            ggtitle(title)
    } else if (str_detect(tolower(dim), "dv")) {
        ggplot(plot_dat, aes(score, vd_dist)) +
            geom_point(alpha = 0.1) +
            geom_smooth(method = "gam") +
            ggtitle(title)
    } else if (str_detect(tolower(dim), "3d")) {
        ggplot(plot_dat, aes(score, dist_3d)) +
            geom_point(alpha = 0.1) +
            geom_smooth(method = "gam") +
            ggtitle(title)
    } else if (str_detect(tolower(dim), "avg")) {
        ggplot(plot_dat, aes(score, avg_dist)) +
            geom_point(alpha = 0.1) +
            geom_smooth(method = "gam") +
            ggtitle(title)
    } #endif 
} #end Simscore_DVPlot

library(dunn.test)
Simscore_BinPlot <- function(class = 2, dv = "Dorsal", dim = "AP", stat = F) {
    plot_dat <- simscore_dist %>% 
        filter(class1 == class, 
               class2 == class, 
               oe1 == dv,
               oe2 == dv,
               dupe == F,)
    
    title <- paste0(dim, " Class", class, " ", dv)
    
    if (stat == T) {
        print(paste("Class:", class, "DV:", dv))
        print("AP Dunn KW")
        print(dunn.test(x = plot_dat$ap_dist, g = plot_dat$score_bin))
        print("DV Dunn KW")
        print(dunn.test(x = plot_dat$vd_dist, g = plot_dat$score_bin))
        print("ML Dunn KW")
        print(dunn.test(x = plot_dat$ml_dist, g = plot_dat$score_bin))
    } #endif stat
    
    if (str_detect(tolower(dim), "ap")) {
        ggplot(plot_dat, aes(score_bin, ap_dist)) +
            geom_boxplot(aes(fill = score_bin), lwd = 1.5, width = 0.5, outlier.shape = NA) +
            scale_fill_manual(values = c("#69747B", "#FEC409", "#BE0004")) +
            scale_color_manual(values = c("#69747B", "#FEC409", "#BE0004")) + #startrekcolors!
            xlab("Pairwise OR Protein Sequence Identity") +
            ylab("AP Distance (sections)") +
            theme_bw() +
            theme_kz() +
            theme(legend.position = "none")
    } else if (str_detect(tolower(dim), "ml")) {
        ggplot(plot_dat, aes(score_bin, ml_dist)) +
            geom_boxplot(aes(fill = score_bin), lwd = 1.5, width = 0.5, outlier.shape = NA) +
            scale_fill_manual(values = c("#69747B", "#FEC409", "#BE0004")) +
            scale_color_manual(values = c("#69747B", "#FEC409", "#BE0004")) +
            xlab("Pairwise OR Protein Sequence Identity") +
            ylab("ML Distance (sections)") +
            theme_bw() +
            theme_kz() +
            theme(legend.position = "none")
    } else if (str_detect(tolower(dim), "dv")) {
        ggplot(plot_dat, aes(score_bin, vd_dist)) +
            geom_boxplot(aes(fill = score_bin), lwd = 1.5, width = 0.5, outlier.shape = NA) +
            #geom_jitter(aes(color = score_bin), alpha = 0.1, width = 0.25) +
            scale_fill_manual(values = c("#69747B", "#FEC409", "#BE0004")) +
            scale_color_manual(values = c("#69747B", "#FEC409", "#BE0004")) +
            xlab("Pairwise OR Protein Sequence Identity") +
            ylab("DV Distance (sections)") +
            theme_bw() +
            theme_kz() +
            theme(legend.position = "none")
    } #endif 
} #end Simscore_BinPlot

#AP
#class 1
simscore_dist %>% filter(class1 == 1, class2 == 1, dupe == F) %>% ggplot(aes(score, ap_dist)) + geom_point(alpha = 0.1) + geom_smooth() + ggtitle("AP - C1 to C1")

#class 2
simscore_dist %>% filter(class1 == 2 & class2 == 2 & dupe == F) %>% ggplot(aes(score, ap_dist)) + geom_point(alpha = 0.1) + geom_smooth() + ggtitle("AP - C2 to C2")

c2dorp <- Simscore_DVPlot(class = 2, dv = "Dorsal", dim = "AP")
c2venp <- Simscore_DVPlot(class = 2, dv = "Ventral", dim = "AP")

c2dbinap <- Simscore_BinPlot(class = 2, dv = "Dorsal", dim = "AP")
c2vbinap <- Simscore_BinPlot(class = 2, dv = "Ventral", dim = "AP")
c2dbindv <- Simscore_BinPlot(class = 2, dv = "Dorsal", dim = "DV")
c2vbindv <- Simscore_BinPlot(class = 2, dv = "Ventral", dim = "DV")
c2dbinml <- Simscore_BinPlot(class = 2, dv = "Dorsal", dim = "ML")
c2vbinml <- Simscore_BinPlot(class = 2, dv = "Ventral", dim = "ML")

c1dbinap <- Simscore_BinPlot(class = 1, dv = "Dorsal", dim = "AP")
c1dbindv <- Simscore_BinPlot(class = 1, dv = "Dorsal", dim = "DV")
c1dbinml <- Simscore_BinPlot(class = 1, dv = "Dorsal", dim = "ML")

SaveRectPlots(c2dbinap, c2dbinml, c2dbindv,
              c2vbinap, c2vbinml, c2vbindv,
              c1dbinap, c1dbinml, c1dbindv, path = "~/Desktop/new")
```


```{r}
# what is the average score of class1 ORs to other class1 ORs and to other class2 ORs
simscore_dist %>% filter(class1 == 1) %>% group_by(class2) %>% summarise(mean_score = mean(score, na.rm=T))
# class 1 to class 1 = ~750, class 1 to class2/NA = ~350

simscore_dist %>% filter(class1 == 2) %>% group_by(class2) %>% summarise(mean_score = mean(score, na.rm=T))
# class 2 to class 1 = 350, class 2 to class 2/NA = ~617

na_or1 <- simscore_dist %>% filter(is.na(class1)) %>% select(olfr1) %>% group_by(olfr1) %>% summarise(count = n()) %>% filter(count > 1) %>% pull(olfr1)

#for ORs with no class, can we determine which class they are by looking at score to class1 and class2 ORs?
for (i in 1:length(na_or1)) {
    print(simscore_dist %>% 
              filter(olfr1 == na_or1[i] | olfr2 == na_or1[i]) %>% 
              group_by(class1, class2) %>% 
              summarise(mean_score = mean(score, na.rm=T),
                        count = n(),
                        olfr = na_or1[i]))
}

#Olfr174, Olfr242, Olfr207 have no wavg so no data except exact match
#Olfr1174 is 336 to C1, 592 to C2 = C2
#Olfr1274 is 360 to C1, 640 to C2 = C2
#Olfr1537 is 331 to C1, 625 to C2 = C2
#Olfr1564 is 346 to C1, 572 to C2 = C2
#Olfr1565 is 360 to C1, 640 to C2 = C2
#Olfr175 is 352 to C1, 613 to C2 = C2
#Olfr237 is 377 to C1, 624 to C2 = C2
#Olfr322 is 311 to C1, 624 to C2 = C2
#Olfr329 is 344 to C1, 591 to C2 = C2
#Olfr391 is 395 to C1, 643 to C2 = C2
# all the above are named as -ps in info
```

# redoing basal stuff

```{r}
# compare new DE to old DE
old_de <- read_csv("~/Desktop/classify_ap/original_basal_diffe.csv") %>% select(id, logFC, FDR)
new_de <- read_csv("~/Desktop/classify_ap/new_basal_allcontrols.csv") %>% select(id, logFC, FDR)

both_de <- left_join(old_de, new_de, by = "id", suffix = c("old", "new"))

old_hi <- old_de %>% filter(FDR < 0.1) %>% filter(logFC > 1) %>% arrange(id) %>% pull(id)
new_hi <- new_de %>% filter(FDR < 0.1) %>% filter(logFC > 1) %>% arrange(id) %>% pull(id)

length(old_hi)
length(new_hi)

length(which(old_hi %in% new_hi))
# all old_hi in new_hi

old_lo <- old_de %>% filter(FDR < 0.1) %>% filter(logFC < -2) %>% arrange(id) %>% pull(id)
new_lo <- new_de %>% filter(FDR < 0.1) %>% filter(logFC < -2) %>% arrange(id) %>% pull(id)

length(old_lo)
length(new_lo)

length(which(old_lo %in% new_lo))
# all old_lo in new_lo

both_de_labels <- both_de %>% 
    mutate(basal_hi = ifelse(id %in% old_hi, "old_hi", ifelse(id %in% new_hi, "new_hi", NA)),
           basal_lo = ifelse(id %in% old_lo, "old_lo", ifelse(id %in% new_lo, "new_lo", NA)),
           basal_any = ifelse(!is.na(basal_hi), "any_hi", ifelse(!is.na(basal_lo), "any_lo", NA)))

# how do old and new DE compare?
ggplot(both_de_labels) +
    geom_point(aes(logFCold, logFCnew, color = basal_any))

ggplot(both_de_labels) +
    geom_point(aes(FDRold, FDRnew, color = basal_any))
#logFCs remain similar but FDRs have diversified

#sortlists
apkz_vnorm <- MakeSort(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, method = "kzsort") %>%
    rename(olfrname = gene) %>%
    select(olfrname, maxsec, avgpos3)

apkz_norm <- MakeSort(m4_norm, m6_norm, m7_norm, m10_norm, method = "kzsort") %>% 
    rename(olfrname = gene) %>%
    select(olfrname, maxsec, avgpos3)

apkz_onorm <- MakeSort(m4_Onorm, m6_Onorm, m7_Onorm, m10_Onorm, method = "kzsort") %>%
    rename(olfrname = gene) %>%
    select(olfrname, maxsec, avgpos3)

#histograms - where are hi/lo basal ORs located?
norm_hi <- apkz_norm %>% 
    filter(olfrname %in% old_hi) %>% 
    ggplot() + 
    geom_histogram(aes(maxsec), bins = 23) + 
    ggtitle("High Basal in NoNorm")

norm_lo <- apkz_norm %>% 
    filter(olfrname %in% old_lo) %>% 
    ggplot() + 
    geom_histogram(aes(maxsec), bins = 23) + 
    ggtitle("Low Basal in NoNorm")

norm_lo + norm_hi

onorm_hi <- apkz_onorm %>% 
    filter(olfrname %in% old_hi) %>% 
    ggplot() + 
    geom_histogram(aes(maxsec), bins = 23) + 
    ggtitle("High Basal in OMP Norm")

onorm_lo <- apkz_onorm %>% 
    filter(olfrname %in% old_lo) %>% 
    ggplot() + 
    geom_histogram(aes(maxsec), bins = 23) + 
    ggtitle("Low Basal in OMP Norm")

onorm_lo + onorm_hi

vnorm_hi <- apkz_vnorm %>% 
    filter(olfrname %in% old_hi) %>% 
    ggplot() + 
    geom_histogram(aes(maxsec), bins = 23) + 
    ggtitle("High Basal in Voxel Norm")

vnorm_lo <- apkz_vnorm %>% 
    filter(olfrname %in% old_lo) %>% 
    ggplot() + 
    geom_histogram(aes(maxsec), bins = 23) + 
    ggtitle("Low Basal in Voxel Norm")

vnorm_lo + vnorm_hi
```


```{r}
# look at positions of these ORs
SubsetBLRH4(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, old_hi)
SubsetBLRH4(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, new_hi)

SubsetBLRH4(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, old_lo)
SubsetBLRH4(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, new_lo)

both_de_info <- both_de %>% 
    rename(olfrname = id) %>% 
    left_join(info, by = "olfrname") %>% 
    left_join(apkz_norm, by = "olfrname") %>%
    select(-class, -RTP, -known) %>%
    mutate(fcoldrank = min_rank(logFCold),
           fcnewrank = min_rank(logFCnew),
           basal = ifelse(olfrname %in% old_hi, "HighBA", ifelse(olfrname %in% old_lo, "LowBA", NA)))

basal_info <- both_de_info %>% filter(!is.na(basal))
ggplot(basal_info %>% filter(basal == "HighBA")) + geom_point(aes(fcoldrank, ap_mp)) + ggtitle("High Basal ORs")
ggplot(basal_info %>% filter(basal == "LowBA")) + geom_point(aes(fcoldrank, ap_mp)) + ggtitle("Low Basal ORs")

ggplot(basal_info) + geom_point(aes(fcoldrank, ap_mp, color = basal)) + ggtitle("Basal ORs")
ggplot(basal_info) + geom_point(aes(logFCold, ap_mp, color = basal)) + ggtitle("Basal ORs")

ggplot(basal_info) + geom_violin(aes(basal, ap_mp, fill = basal)) + ggtitle("Basal ORs")

#max section like
ggplot(basal_info %>% filter(basal == "HighBA")) + geom_histogram(aes(maxsec), bins = 23)
ggplot(basal_info %>% filter(basal == "LowBA")) + geom_histogram(aes(maxsec), bins = 23)
ggplot(basal_info) + geom_violin(aes(basal, maxsec, fill = basal)) + ggtitle("High Basal ORs")

#how similar is mean position to maxsec?
ggplot(basal_info, aes(ap_mp, maxsec)) + geom_point() + geom_smooth() + ggtitle("MaxSec vs Mean Position")
```


# examine ORs tested by Sakano for in vitro basal activity
```{r}
#2 group is anterior+middle vs posterior
#rank is apmp_rank (min_rank(ap_wavg)) vs wavg (ap_wavg)
#scale_fill_manual values are green, grey, red c("#00F800","#404A45", "#FF0000")) matching nakashima 2013
#scale_shape_manual values are circle, diamond, square c(21,23,22))
#if doing 2 group, kickout grey and diamond

info <- read_csv("~/Desktop/info_210430.csv")

sak_compare <- sak_tib %>%
    left_join(info, by = "olfrname") %>%
    mutate(cloned_position = ifelse(group == "Posterior", "Posterior", "Anterior+Middle"),
           apmp_rank = min_rank(ap_wavg),
           oe_tanna = ifelse(is.na(tz_vd), oe_region, tz_vd)) %>%
    filter(filterFail == F)

#stats, nonparametric so identical to using ap_wavg
dorsalMWU <- sak_compare %>% filter(oe_tanna == "Dorsal")
wilcox.test(dorsalMWU$apmp_rank ~ dorsalMWU$cloned_position) #notsig

ventralMWU <- sak_compare %>% filter(oe_tanna == "Ventral")
wilcox.test(ventralMWU$apmp_rank ~ ventralMWU$cloned_position) #sig

#with wavgs
sak2_wavg_allpoints <- sak_compare %>%
    ggplot() + 
    geom_point(aes(ap_wavg, rank, fill = group, shape = group), 
                          size = 5, color = "black") +
    labs(x = "AP Mean Position", y = "Sakano in vitro Activity Rank") +
    theme_bw() +
    scale_fill_manual(values = c("#00F800", "#404A45", "#FF0000")) +
    scale_shape_manual(values = c(21, 23, 22)) +
    theme(legend.position = "none") +
    theme_kz()

#facet by position
sak2_wavg_dvpoints_tzoe <- sak_compare %>%
    ggplot() + 
    geom_point(aes(ap_wavg, rank, fill = cloned_position, shape = cloned_position), 
                          size = 4, color = "black") +
    facet_wrap(~ oe_tanna) +
    labs(x = "AP Mean Position", y = "Sakano in vitro Activity Rank") +
    theme_bw() +
    scale_fill_manual(values = c("#00F800", "#FF0000")) +
    scale_shape_manual(values = c(21,22)) +
    theme(legend.position = "none",
          panel.grid.minor = element_blank()) +
    theme_kz()

#info position as boxplot
sak2_wavg_dvbox_tzoe <- sak_compare %>%
    ggplot() + 
    geom_boxplot(aes(cloned_position, ap_wavg, fill = cloned_position)) +
    facet_wrap(~ oe_tanna) +
    labs(x = "Sakano AP Group", y = "AP Mean Position Rank") +
    theme_bw() +
    theme(legend.position = "none") +
    scale_fill_manual(values = c("#00F800", "#FF0000")) +
    theme(legend.position = "none",
          panel.grid.minor = element_blank()) +
    theme_kz()

# doing rank instead of wavg
sak2_rank_allpoints <- sak_compare %>%
    ggplot() + 
    geom_point(aes(apmp_rank, rank, fill = group, shape = group), 
                          size = 5, color = "black") +
    labs(x = "AP Mean Position Rank", y = "Sakano in vitro Activity Rank") +
    theme_bw() +
    scale_fill_manual(values = c("#00F800", "#404A45", "#FF0000")) +
    scale_shape_manual(values = c(21, 23, 22)) +
    theme(legend.position = "none") +
    theme_kz()

sak2_rank_dvpoints_tzoe <- sak_compare %>%
    ggplot() + 
    geom_point(aes(apmp_rank, rank, fill = cloned_position, shape = cloned_position), 
                          size = 4, color = "black") +
    facet_wrap(~ oe_tanna) +
    labs(x = "AP Mean Position Rank", y = "Sakano in vitro Activity Rank") +
    theme_bw() +
    scale_fill_manual(values = c("#00F800", "#FF0000")) +
    scale_shape_manual(values = c(21,23, 22)) +
    theme(legend.position = "none",
          panel.grid.minor = element_blank()) +
    theme_kz()

sak2_rank_dvbox_tzoe <- sak_compare %>%
    ggplot() + 
    geom_boxplot(aes(cloned_position, apmp_rank, fill = cloned_position)) +
    facet_wrap(~ oe_tanna) +
    labs(x = "Sakano AP Group", y = "AP Mean Position") +
    theme_bw() +
    theme(legend.position = "none",
          panel.grid.minor = element_blank()) +
    scale_fill_manual(values = c("#00F800", "#FF0000")) +
    theme_kz()

#with legends
sak2_legend <- sak_compare %>%
    ggplot() + 
    geom_point(aes(apmp_rank, rank, fill = group, shape = group), 
                          size = 5, color = "black") +
    labs(x = "AP Mean Position Rank", y = "Sakano in vitro Activity Rank") +
    theme_bw() +
    scale_fill_manual(values = c("#00F800", "#404A45", "#FF0000")) +
    scale_shape_manual(values = c(21, 23, 22)) +
    theme_kz()

sak2_facet_legend <- sak_compare %>%
    ggplot() + 
    geom_point(aes(apmp_rank, rank, fill = cloned_position, shape = cloned_position), 
                          size = 4, color = "black") +
    facet_wrap(~ oe_tanna) +
    labs(x = "AP Mean Position Rank", y = "Sakano in vitro Activity Rank") +
    theme_bw() +
    scale_fill_manual(values = c("#00F800", "#FF0000")) +
    scale_shape_manual(values = c(21,23, 22)) +
    theme_kz()

SaveRectPlots(sak2_legend, sak2_facet_legend,
              sak2_rank_allpoints, sak2_rank_dvbox_tzoe, sak2_rank_dvpoints_tzoe,
              sak2_wavg_allpoints, sak2_wavg_dvbox_tzoe, sak2_rank_dvpoints_tzoe,
              path = "~/Desktop/heatmaps/basal/ompdv22/")
```


# are heatmap outliers real?
By real I guess we mean are they present across replicates at similar expression levels
Could look at Olfr-Position cells by recording values from multiple replicates
Could binarise (1 is value greater than 0/0.25/0.5) and heatmap presence across replicates
This lead to using median values for AP heatmaps
```{r}
# binarise matrix cells above value
Above_value <- function(df_in, value) {
    #setting high values to 1 prior to setting low values to 0 can result in an all 0 matrix if the value is greater than 1
    df_above <- df_in
    df_above[df_above < value] <- 0
    df_above[df_above >= value] <- 1
    return(df_above)
}


# Heatmap based on replicate consistency for values 
HeatConsist <- function(..., expression_val, repconsist_val = NA, sort, out = "heatmap") {
    args <- list(...)
    
    if (length(args) == 3) {
        df1_above <- Above_value(args[[1]], value = expression_val)
        df2_above <- Above_value(args[[2]], value = expression_val)
        df3_above <- Above_value(args[[3]], value = expression_val)
        
        df_merge <- matrix(nrow = nrow(df1_above), ncol = ncol(df1_above))
        
        for (i in 1:ncol(df_merge)) {
            df_merge[,i] <- df1_above[,i] + df2_above[,i] + df3_above[,i]
        } #endfor
    } else if (length(args) == 4) {
        df1_above <- Above_value(args[[1]], value = expression_val)
        df2_above <- Above_value(args[[2]], value = expression_val)
        df3_above <- Above_value(args[[3]], value = expression_val)
        df4_above <- Above_value(args[[4]], value = expression_val)
        
        df_merge <- matrix(nrow = nrow(df1_above), ncol = ncol(df1_above))
        
        for (i in 1:ncol(df_merge)) {
            df_merge[,i] <- df1_above[,i] + df2_above[,i] + df3_above[,i] + df4_above[,i]
        } #endfor
    } #endif
    
    #select repconsist
    if (is.na(repconsist_val)) {
        #dont care about consistency between replicates, so normalize
        consist_norm <- matrix(nrow = nrow(df_merge), ncol = ncol(df_merge))
        for (i in 1:nrow(df_merge)) {
            consist_norm[i,] <- NormalizeMaxMin(df_merge[i,])
        } #endfor
        hmtitle <- paste0("Consistency of expression above ", expression_val)
    } else {
        consist_norm <- Above_value(df_merge, value = repconsist_val)
        hmtitle <- paste0("Expression above ", expression_val, 
                          " in ", repconsist_val, "+ replicates")
    }
    
    #name rows and columns
    colnames(consist_norm) <- colnames(args[[1]])
    rownames(consist_norm) <- rownames(args[[1]])
    if (out == "df") {
        return(consist_norm)
    } else if (out == "heatmap") {
        hm_sort <- SortByList(consist_norm, sort)
        hm <- MakeBlackRedHeatmap(hm_sort, title = hmtitle)
        return(hm)
    } #endif
} #end HeatConsist

gra <- HeatConsist(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, 
                   expression_val = 0.1, repconsist_val = 4, sort = m46710_voxsort, out = "heatmap")
gra

consist_list <- vector("list", length = 12)
repvals <- c(1, 2, 3, 4)
expvals <- c(0.25, 0.5, 0.75)
counter <- 1
for (i in 1:length(repvals)) {
    for (j in 1:length(expvals)) {
        consist_list[[counter]] <- HeatConsist(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm,
                                               expression_val = expvals[j], 
                                               repconsist_val = repvals[i],
                                               sort = m46710_voxsort,
                                               out = "heatmap")
        counter <- counter + 1
    }
}

consist_list[[1]]
```


# examine covariance

```{r, eval=F}
meanpos_dist <- matrix(nrow = nrow(meanpos_mtx), ncol = nrow(meanpos_mtx))
for (i in 1:nrow(meanpos_mtx)) {
    for (j in 1:nrow(meanpos_mtx)) {
        meanpos_dist[i,j] <- sum(abs(meanpos_mtx[i,] - meanpos_mtx[j,]))/10
    }
}

#are high correlation pairs close in distance?
sd(meanpos_cor)
bestcor <- which(meanpos_cor > 0.6)
sd(meanpos_dist)
bestdistmean <- which(meanpos_dist < 2.5)

bestdistmean[which(bestdistmean < 783)]

bdm_rank <- matrix(nrow = nrow(meanpos_dist), ncol = ncol(meanpos_dist))
for (i in 1:nrow(meanpos_dist)) {
    bdm_rank[i,] <- min_rank(meanpos_dist[i,])
}
which(bdm_rank == 2)
rownames(bdm_rank) <- ornames
colnames(bdm_rank) <- ornames

#should we group by dim, determine avgpos of dim, and then compare distance/correlation?
ap_meanpos <- meanpos_tb %>% select(gene_id, m4_AP, m6_AP, m7_AP, m10_AP) %>% mutate(mean_AP = (m4_AP + m6_AP + m7_AP + m10_AP)/4)
vd_meanpos <- meanpos_tb %>% select(gene_id, m9_VD, m12_VD, m14_VD) %>% mutate(mean_VD = (m9_VD + m12_VD + m14_VD)/3)
#excluding m16 due to poor correlation with m8 and m11
#cor(ml_meanpos$m8_ML, ml_meanpos$m16_ML) = -0.2465, -.409 for m11vsm16
ml_meanpos <- meanpos_tb %>% select(gene_id, m8_ML, m11_ML) %>% mutate(mean811_ML = (m8_ML + m11_ML)/2)

dimmeanpos <- data.frame(ap_meanpos$mean_AP, vd_meanpos$mean_VD, ml_meanpos$mean811_ML) %>% data.matrix
dimmeanpos_tb <- ap_meanpos %>% select(gene_id, mean_AP) %>% mutate(mean_VD = vd_meanpos$mean_VD, mean_ML = ml_meanpos$mean811_ML)
#plot as 3D scatter
plot_ly(type = "scatter3d", mode = "markers") %>% 
    add_trace(data=dimmeanpos_tb, x= ~mean_AP, y= ~mean_ML, z= ~mean_VD,
              text = ~paste('Gene: ', gene_id,
                            '<br>AP:', mean_AP, 
                            '<br>ML:', mean_ML,
                            '<br>VD:', mean_VD),
              marker = list(size = 6, line = list(color = 'black', width = 0.5))) %>%
    layout(scene = list(xaxis = list(title = 'Anterior-Posterior'),
                        yaxis = list(title = 'Medial-Lateral'),
                        zaxis = list(title = 'Ventral-Dorsal')))

dim_dist <- matrix(nrow = nrow(dimmeanpos), ncol = nrow(dimmeanpos))
for (i in 1:nrow(dimmeanpos)) {
    for (j in 1:nrow(dimmeanpos)) {
        dim_dist[i,j] <- sum(abs(dimmeanpos[i,] - dimmeanpos[j,]))/3
    }
}

#using the distance between dimensional mean positions, define clusters
#for each OR, rank 1 = least distance
dd_rank <- matrix(nrow = nrow(dim_dist), ncol = nrow(dim_dist))
for (i in 1:nrow(dim_dist)) {
    dd_rank[i,] <- min_rank(dim_dist[i,])
}

#pick 2 to 6 since the diagonal is 0 which becomes rank 1
top5 <- which(between(x = dd_rank, left = 2, right = 6)) 
dd_bin <- matrix(nrow = nrow(dd_rank), ncol = nrow(dd_rank), data = 0)
dd_bin[top5] <- 1

#cluster matrix
cluster_list <- rep(NA, nrow(dd_bin))
for (k in 1:ncol(dd_bin)) {
    #skip points that are already in a cluster
    if (is.na(cluster_list[k])) {
        round <- 1
        #do a bunch of rounds, find a way to have it run until it stops finding new points
        while (round < 3) {
            neigh <- which(dd_bin[,k] == 1)
            #for each neighbor of previous round of neighbors, find new neighbors
            for (l in 1:length(neigh)) {
                neigh <- c(neigh, which(dd_bin[,neigh[l]] == 1))
                neigh <- neigh[-which(duplicated(neigh))]
                neigh <- sort(neigh)
            } #endforl
            round <- round + 1
        } #endwhile
        cluster_list[neigh] <- k
    } else {
        next
    } #endif
} #endfork
```


## Compare Ant and Post Peak Positions across mice

```{r}
appp_vnorm <- MultiAPPP(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, "_m4", "_m6", "_m7", "_m10")

forcomboant <- appp_vnorm %>% select(antpeak_m4, antpeak_m6) %>%
    rename(combo4 = antpeak_m4, combo6 = antpeak_m6)
forcombopost <- appp_vnorm %>% select(postpeak_m4, postpeak_m6) %>%
    rename(combo4 = postpeak_m4, combo6 = postpeak_m6)
forcombo <- bind_rows(forcomboant, forcombopost)

#plot ant vs ant, post vs post
ggplot(appp_vnorm) +
    geom_jitter(aes(antpeak_m4, antpeak_m6), color = "red", alpha = 0.4) +
    geom_jitter(aes(postpeak_m4, postpeak_m6), color = "blue", alpha = 0.4) +
    geom_abline(slope = 1) + 
    geom_smooth(data = forcombo, aes(combo4, combo6), color = "purple", method = "lm", se=F)

# #above as boxes or violins
# ggplot(appp_vnorm %>% mutate(apm4 = antpeak_m4 + 100, ppm4 = postpeak_m4 + 100)) +
#   geom_boxplot(aes(as.character(apm4), antpeak_m6), color = "red", alpha = 0.3) +
#   geom_boxplot(aes(as.character(ppm4), postpeak_m6), color = "blue", alpha = 0.3)
# 
# #above as faceted for ant and post
# m46facet_a <- appp_vnorm %>% select(gene, antpeak_m4, antpeak_m6) %>% 
#   mutate(ap = "ant") %>% 
#   rename(peak_4 = antpeak_m4, peak_6 = antpeak_m6)
# m46facet_p <- appp_vnorm %>% select(gene, postpeak_m4, postpeak_m6) %>% 
#   mutate(ap = "post") %>% 
#   rename(peak_4 = postpeak_m4, peak_6 = postpeak_m6)
# m46facet <- bind_rows(m46facet_a, m46facet_p)
# 
# ggplot(m46facet) + 
#   geom_boxplot(aes(as.character(peak_4 + 100), peak_6)) +
#   facet_grid(ap ~ .)


# examine distances for ant and post peaks between mice
# calculate distances
appp_vnorm_dist <- appp_vnorm %>% mutate(antdist_46 = abs(antpeak_m4 - antpeak_m6),
                                         antdist_47 = abs(antpeak_m4 - antpeak_m7),
                                         antdist_410 = abs(antpeak_m4 - antpeak_m10),
                                         antdist_67 = abs(antpeak_m6 - antpeak_m7),
                                         antdist_610 = abs(antpeak_m6 - antpeak_m10),
                                         antdist_710 = abs(antpeak_m7 - antpeak_m10),
                                         antdistmean_46710 = (antdist_46 + antdist_47 + 
                                                                  antdist_410 + antdist_67 +
                                                                  antdist_610 + antdist_710)/6,
                                         postdist_46 = abs(postpeak_m4 - postpeak_m6),
                                         postdist_47 = abs(postpeak_m4 - postpeak_m7),
                                         postdist_410 = abs(postpeak_m4 - postpeak_m10),
                                         postdist_67 = abs(postpeak_m6 - postpeak_m7),
                                         postdist_610 = abs(postpeak_m6 - postpeak_m10),
                                         postdist_710 = abs(postpeak_m7 - postpeak_m10),
                                         postdistmean_46710 = (postdist_46 + postdist_47 + 
                                                                   postdist_410 + postdist_67 +
                                                                   postdist_610 + postdist_710)/6,
                                         aptotal_46 = antdist_46 + postdist_46,
                                         aptotal_47 = antdist_47 + postdist_47,
                                         aptotal_410 = antdist_410 + postdist_410,
                                         aptotal_67 = antdist_67 + postdist_67,
                                         aptotal_610 = antdist_610 + postdist_610,
                                         aptotal_710 = antdist_710 + postdist_710,
                                         aptotal_mean = (aptotal_46 + aptotal_47 +
                                                             aptotal_410 + aptotal_67 + 
                                                             aptotal_610 + aptotal_710)/6,
                                         apmean_46 = (antdist_46 + postdist_46)/2,
                                         apmean_47 = (antdist_47 + postdist_47)/2,
                                         apmean_410 = (antdist_410 + postdist_410)/2,
                                         apmean_67 = (antdist_67 + postdist_67)/2,
                                         apmean_610 = (antdist_610 + postdist_610)/2,
                                         apmean_710 = (antdist_710 + postdist_710)/2,
                                         apmean_mean = (apmean_46 + apmean_47 +
                                                            apmean_410 + apmean_67 +
                                                            apmean_610 + apmean_710)/6)

#test correlation
cor(appp_vnorm$antpeak_m4, appp_vnorm$antpeak_m6, method = "spearman")

#how many ORs have identical distance between ant and post peak (could be diff directions thou)
length(which(appp_vnorm_dist$antdist_46 == appp_vnorm_dist$postdist_46))

#plot distance between ant peaks for m4 and m6
#for these two mice, most ORs have anterior peaks that are within 2 sections
ggplot(appp_vnorm_dist) + 
    geom_histogram(aes(antdist_46), fill = "red")

#plot distance between post peaks for m4 and m6
#for these two mice, most ORs have posterior peaks that are within 2.5 sections
ggplot(appp_vnorm_dist) + 
    geom_histogram(aes(postdist_46), fill = "blue")

#plot mean distance between all mice for all ant and all post peaks for each OR
#across all mice, most ORs have anterior and posterior peaks within 5 sections 
ggplot(appp_vnorm_dist) + 
    geom_histogram(aes(apmean_mean))

#plot ant vs post distance for m4 vs m6
#for these two mice, most ORs have anterior and posterior peaks within 2 sections
#46 = 2
#47 = 4
#410 = 4
#67 = 3
#610 = 4
#710 = 4
ggplot(appp_vnorm_dist %>% group_by(antdist_46, postdist_46) %>% mutate(count = n()))  + 
    geom_point(aes(antdist_46, postdist_46, size = count), alpha = 0.25) + 
    geom_smooth(aes(antdist_46, postdist_46))

#plot ant vs post distance mean for all mice
ggplot(appp_vnorm_dist %>% group_by(antdistmean_46710, postdistmean_46710) %>% mutate(count = n())) +
    geom_point(aes(antdistmean_46710, postdistmean_46710, size = count), alpha = 0.25) + 
    geom_smooth(aes(antdistmean_46710, postdistmean_46710))
```

# Use heatmap information to determine OB symmetry line

Should be slanted across the OB moving more laterally as it moves more posterior

```{r}
#hmm im not really seeing what i expect
#basically says an ML plane ~13 is the symmetry line
#SymLiner(m46710mergeV_voxnormsort, m91214mergeV_voxnormsort, m81116mergeV_voxnormsort, out="plot")

#lets try a single replicate
dr1 <- SymLiner(m10_Vnorm, m9_Vnorm, m8_Vnorm)
dr2 <- SymLiner(m13_Vnorm, m12_Vnorm, m11_Vnorm)
dr3 <- SymLiner(m15_Vnorm, m14_Vnorm, m16_Vnorm)

fit1 <- SymLiner(m10_Vnorm, m9_Vnorm, m8_Vnorm, out = "fit")
fit2 <- SymLiner(m13_Vnorm, m12_Vnorm, m11_Vnorm, out = "fit")
fit3 <- SymLiner(m15_Vnorm, m14_Vnorm, m16_Vnorm, out = "fit")

intercepts <- c(fit1[[1]], fit2[[1]], fit3[[1]])
slopes <- c(fit1[[2]], fit2[[2]], fit3[[2]])
mean(intercepts)
mean(slopes)

SymLiner(m10_Vnorm, m9_Vnorm, m8_Vnorm, out = "plot")
SymLiner(m13_Vnorm, m12_Vnorm, m11_Vnorm, out = "plot")
SymLiner(m15_Vnorm, m14_Vnorm, m16_Vnorm, out = "plot")

symlineplot <- ggplot() +
    geom_blank() +
    geom_abline(aes(slope = slopes[1], intercept = intercepts[1], color = "rep1"), size = 2) +
    geom_abline(aes(slope = slopes[2], intercept = intercepts[2], color = "rep2"), size = 2) +
    geom_abline(aes(slope = slopes[3], intercept = intercepts[3], color = "rep3"), size = 2) +
    xlim(0,23) +
    ylim(0,22) + 
    ggtitle("OB Symmetry from AP+ML heatmap peaks") +
    xlab("Mean position of top 2 AP peaks") +
    ylab("Mean position of top 2 ML peaks") +
    theme_cowplot()

symlineplot
#SaveSquarePlots(symlineplot, path = "~/Desktop/obmap/r_analysis/heatmaps/output/")

apvals <- c(1:28)
mlvals <- vector(length = length(apvals), mode = "numeric")
for (i in 1:length(apvals)) {
    mlvals[i] <- round(mean(intercepts) + mean(slopes) * apvals[i], digits = 2)
}

#output symline positions for voxels
symline <- tibble(apvals, mlvals)
#write_csv(symline, "~/Desktop/obmap/r_analysis/heatmaps/output/symline_3rep.csv")

#for dr1: m10 and m8, goes from 8.83 to 14.3 while AP moves 1->23 (slope = 0.24922)
#for dr2: m11 and m13, ML symmetry line goes from 7.61 to 14.8 while AP moves 1->23 (slope = 0.32655)
#i think the ml and ap ones are trimmed to fit multiple replicates, may need to use original to see if any differences in symline arise

#test other indiv replicates as well as all ap vs all ml
#export results for v20 model


#perhaps I should not be using mice averaged peaks and instead do AP1 vs ML1 etc.
#or i could be discounting ORs whose glomeruli lie very close the symmetry line in the ML dim since AntPeakPostPeak function has a minimum distance of separation
```

# Get Peaks for all AP and ML dims in order to make mock 3D projection

DV location comes from tanindex

```{r}
ap_allreps <- MultiAPPP(m4_Vnorm, m6_Vnorm, m7_Vnorm, m10_Vnorm, 
                        "_ap4", "_ap6", "_ap7", "_ap10")
# ap_first should be more lateral
ap_first <- ap_allreps %>% select(gene, contains("ant")) %>%
    rename(AntPos4 = antpeak_ap4, AntPos6 = antpeak_ap6, 
           AntPos7 = antpeak_ap7, AntPos10 = antpeak_ap10,
           APval4 = antval_ap4, APval6 = antval_ap6,
           APval7 = antval_ap7, APval10 = antval_ap10) %>%
    rowwise() %>%
    mutate(side = "Lateral",
           AntPosAvg = mean(c(AntPos4, AntPos6, AntPos7, AntPos10))) %>%
    ungroup()
# ap_second should be more medial
ap_second <- ap_allreps %>% select(gene, contains("post"))%>%
    rename(AntPos4 = postpeak_ap4, AntPos6 = postpeak_ap6, 
           AntPos7 = postpeak_ap7, AntPos10 = postpeak_ap10,
           APval4 = postval_ap4, APval6 = postval_ap6,
           APval7 = postval_ap7, APval10 = postval_ap10) %>%
    mutate(side = "Medial",
           AntPosAvg = mean(c(AntPos4, AntPos6, AntPos7, AntPos10))) %>%
    ungroup()

ml_allreps <- MultiAPPP(m8_voxsort, m11_voxsort, m13_voxsort, m13_voxsort, 
                        "_ml8", "_ml11", "_ap13", "_ap14") %>% 
    select(-antpeak_ap14, -postpeak_ap14, -antval_ap14, -postval_ap14)
# ml_first is more medial
ml_first <- ml_allreps %>% 
    select(gene, antpeak_ml8, antpeak_ml11, postpeak_ap13, 
           antval_ml8, antval_ml11, postval_ap13) %>%
    rename(MedLat8 = antpeak_ml8, MedLat11 = antpeak_ml11, 
           AntPos13 = postpeak_ap13,
           MLval8 = antval_ml8, MLval11 = antval_ml11,
           APval13 = postval_ap13) %>%
    rowwise() %>%
    mutate(MedLatAvg = mean(c(MedLat8, MedLat11))) %>%
    ungroup()
# ml_second is more lateral
ml_second <- ml_allreps %>% 
    select(gene, postpeak_ml8, postpeak_ml11,  
           antpeak_ap13, postval_ml8, postval_ml11, antval_ap13) %>%
    rename(MedLat8 = postpeak_ml8, MedLat11 = postpeak_ml11,
           AntPos13 = antpeak_ap13, MLval8 = postval_ml8, 
           MLval11 = postval_ml11, APval13 = antval_ap13) %>%
    rowwise() %>%
    mutate(MedLatAvg = mean(c(MedLat8, MedLat11))) %>%
    ungroup()

vd_allreps <- MultiAPPP(m9_voxsort, m12_voxsort, m14_voxsort, m15_voxsort, 
                        "_vd9", "_vd12", "_vd14", "_ap15")
vd_first <- vd_allreps %>% select(gene, contains("ant")) %>%
    rename(VenDor9 = antpeak_vd9, VenDor12 = antpeak_vd12, 
           VenDor14 = antpeak_vd14, AntPos15 = antpeak_ap15,
           VDval9 = antval_vd9, VDval12 = antval_vd12,
           VDval14 = antval_vd14, APval15 = antval_ap15) %>%
    rowwise() %>%
    mutate(VenDorAvg = mean(c(VenDor9, VenDor12, VenDor14))) %>%
    ungroup()
vd_second <- vd_allreps %>% select(gene, contains("post")) %>%
    rename(VenDor9 = postpeak_vd9, VenDor12 = postpeak_vd12, 
           VenDor14 = postpeak_vd14, AntPos15 = postpeak_ap15,
           VDval9 = postval_vd9, VDval12 = postval_vd12,
           VDval14 = postval_vd14, APval15 = postval_ap15) %>%
    rowwise() %>%
    mutate(VenDorAvg = mean(c(VenDor9, VenDor12, VenDor14))) %>%
    ungroup() 

#using vd first for both
lateral_join <- left_join(ap_first, ml_second, by = "gene") %>% left_join(vd_first, by = "gene")
medial_join <- left_join(ap_second, ml_first, by = "gene") %>% left_join(vd_second, by = "gene")

heatmap_peaks <- bind_rows(lateral_join, medial_join) %>% 
    rename(olfrname = gene) %>%
    rowwise() %>%
    mutate(AntPosAvg = mean(c(AntPos4, AntPos6, AntPos7, AntPos10, AntPos13, AntPos15))) %>%
    ungroup() %>%
    left_join(info, by = "olfrname") %>%
    arrange(olfrname) %>%
    group_by(olfrname) %>%
    mutate(VDavg = mean(c(VenDorAvg)))

#write_csv(heatmap_peaks, "~/Desktop/obmap/r_analysis/heatmaps/output/heatmap_peaks.csv")
```

```{r}
ap_vox <- m46710_voxsort %>% rename(AntPos = sortrank) %>% rename(ap_mp = wavgs, ap_rank = AntPos)
vd_vox <- m91214_voxsort %>% rename(VenDor = sortrank) %>% rename(vd_mp = wavgs, vd_rank = VenDor)
ml_vox <- m81116_voxsort %>% rename(MedLat = sortrank) %>% rename(ml_mp = wavgs, ml_rank = MedLat)
ranklist <- left_join(ap_vox, vd_vox, by = "gene")
ranklist2 <- left_join(ranklist, ml_vox, by = "gene")
#write_csv(ranklist2, "~/Desktop/obmap/r_analysis/heatmaps/output/dim_ranklist_201129.csv")
```

## compare DV mean position vs tan/luis indexes, look at outliers, see if i can create something that relates to 3D DV

```{r, message=F}
ls_idx <- read_csv("~/Desktop/obmap/r_analysis/3dimOB/input/LS_3Dindexes_real_pred.csv")

ap_meanpos <- m46710_voxsort %>%
    rename("olfrname" = "gene",
           "ap_wavgs" = "wavgs",
           "ap_sortrank" = "sortrank")

dv_compare <- m91214_voxsort %>% 
    rename("olfrname" = "gene") %>% 
    left_join(info, by = "olfrname") %>%
    left_join(ap_meanpos, by = "olfrname") %>%
    filter(!is.na(tz_val)) %>% 
    filter(!is.na(DPT_index)) %>%
    filter(!is.na(oe_region)) %>%
    mutate(tzflip = 6 - as.numeric(tan_zone), 
           wavgbin = round(wavgs), 
           isDor = ifelse(oe_region == "Dorsal", 1, 0),
           isTanDori = ifelse(tz_vd == "Dorsal", 1, 0)) %>% 
    filter(!is.na(tz_val)) %>% 
    group_by(wavgbin) %>%
    mutate(mean_dpt = mean(DPT_index), 
           sd_dpt = sd(DPT_index) * 1.645, 
           dptsdhi = mean_dpt + sd_dpt, 
           dptsdlo = mean_dpt - sd_dpt) %>%
    ungroup() %>%
    rowwise() %>%
    mutate(checkout = ifelse(DPT_index > dptsdhi, "ahi", 
                             ifelse(DPT_index < dptsdlo, "zlo", 
                                    "mid")))

ggplot(dv_compare, aes(wavgs, tzflip, color = fisurface)) + 
    geom_point() +
    geom_smooth() +
    ggtitle("Tan Index")

ggplot(dv_compare, aes(wavgs, DPT_index)) + 
    geom_point() +
    geom_smooth() +
    ggtitle("Luis Index")

ggplot(dv_compare, aes(wavgbin, DPT_index, color = checkout)) +
    geom_point() +
    geom_smooth() +
    xlab("Mean Position - Ventral to Dorsal") +
    ggtitle("Luis Index - 1.645SD outliers")

ggplot(dv_compare, aes(wavgs, tzflip, color = ap_wavgs)) +
    geom_point() +
    scale_color_viridis_c() +
    ggtitle("More dorsal ORs are also more anterior")

plot_ly(type = "scatter", mode = "markers") %>%
    add_trace(data = dv_compare, x = ~wavgbin, y = ~DPT_index, 
              color = ~checkout, size = 2,
              text = ~paste('Gene:', olfrname, 
                            '<br>wavgbin:', wavgbin, 
                            '<br>DPTindex:', DPT_index),
              marker = list(size = 6))
#wavg = 3 is quite high in terms of DPTindex
#wavg = 20 is quite low in terms of DPTindex

dv_compare %>% group_by(wavgbin) %>% summarise(count = n(),
                                               meanDPT = mean(DPT_index), 
                                               meantz = mean(tzflip),
                                               propDor = sum(isDor)/count,
                                               propTan = sum(isTanDori)/count) %>%
    ggplot() +
    geom_line(aes(wavgbin, propTan), color = "red") +
    geom_line(aes(wavgbin, propDor), color = "blue") +
    geom_point(aes(wavgbin, propTan), size = 2, color = "red") +
    geom_point(aes(wavgbin, propDor), size = 2, color = "blue") +
    ggtitle("Proportion of ORs that are Tan/Matsu Dorsal in heatmap section",
            subtitle = "Tan = Red, Matsunami = Blue") +
    theme_cowplot()

dv_compare %>% group_by(wavgbin) %>% summarise(count = n(),
                                               meanDPT = mean(DPT_index), 
                                               meantz = mean(tzflip),
                                               propDor = sum(isDor)/count) %>%
    ggplot() + 
    geom_line(aes(wavgbin, meanDPT), color = "red") + 
    geom_line(aes(wavgbin, meantz*10), color = "blue") +
    geom_line(aes(wavgbin, count), color = "green") +
    geom_line(aes(wavgbin, propDor * 100), color = "purple") +
    geom_point(aes(wavgbin, meanDPT), color = "red", size = 2) + 
    geom_point(aes(wavgbin, meantz*10), color = "blue", size = 2) +
    geom_point(aes(wavgbin, count), color = "green", size = 2) +
    geom_point(aes(wavgbin, propDor * 100), color = "purple", size = 2) +
    ggtitle("Tan (x10, blue), Luis (red), MatsuDE (purple), # ORs (green)")

#idea: define set of best predicted 3D DVreceptors (good relation to tan/luis/VDwavg), use to re-predict "bad" predictions?  or perhaps this just leads to more avg values?  would need to do for both medial and lateral halves, perhaps ignore tan and use DPT since more ORs have DPT index
#predictors would be ORs across samples matrix with training set having AP,ML,VD predictions
#do i need to predict one dim at a time?  also need to avoid non-scaffold spaces
#perhaps some sort of dim reduction to "unwrap" OB scaffold into 2d space, then transform tpm matrix into dimred space?
#would need to check if "good" predictions have multiple expression patterns

```

# Filter for uniformity and TPM

Run on non-filtered ORs

```{r, eval=F}
uni_heatmaps_ap4 <- UniformityFilter(m4_vnorm, ranklist = oc_sort)

uni_heatmaps_dv9 <- UniformityFilter(m9_vnorm, ranklist = vd_oc)

uni_heatmaps_ml11 <- UniformityFilter(m11_vnorm, ranklist = ml_oc)

uni_heatmaps_ap4
uni_heatmaps_dv9
uni_heatmaps_ml8


#ap
m4_uni <- UniformityFilter(m4_vnorm, out = "stat")
m6_uni <- UniformityFilter(m6_vnorm, out = "stat")
m7_uni <- UniformityFilter(m7_vnorm, out = "stat")
m10_uni <- UniformityFilter(m10_vnorm, out = "stat")
#m13_uni <- UniformityFilter(m13_vnorm, out = "stat")
#m15_uni <- UniformityFilter(m15_vnorm, out = "stat")
ap_uni <- tibble(gene = m4_uni$gene,
                 uni4 = m4_uni$isUniform,
                 uni6 = m6_uni$isUniform,
                 uni7 = m7_uni$isUniform,
                 uni10 = m10_uni$isUniform)#,
                 uni13 = m13_uni$isUniform,
                 uni15 = m15_uni$isUniform)

#dv
m9_uni <- UniformityFilter(m9_vnorm, out = "stat")
m12_uni <- UniformityFilter(m12_vnorm, out = "stat")
m14_uni <- UniformityFilter(m14_vnorm, out = "stat")
dv_uni <- tibble(gene = m9_uni$gene,
                 uni9 = m9_uni$isUniform,
                 uni12 = m12_uni$isUniform,
                 uni14 = m14_uni$isUniform)

#ml
m8_uni <- UniformityFilter(m8_vnorm, out = "stat")
m11_uni <- UniformityFilter(m11_vnorm, out = "stat")
m16_uni <- UniformityFilter(m16_vnorm, out = "stat")
ml_uni <- tibble(gene = m8_uni$gene,
                 uni8 = m8_uni$isUniform,
                 uni11 = m11_uni$isUniform,
                 uni16 = m16_uni$isUniform)

all_uni <- left_join(ap_uni, dv_uni, by = "gene") %>% 
    left_join(ml_uni, by = "gene") %>%
    mutate(ap_score = uni4 + uni6 + uni7 + uni10,# + uni13 + uni15,
           dv_score = uni9 + uni12 + uni14,
           ml_score = uni8 + uni11 + uni16,
           all_score = ap_score + dv_score + ml_score) %>%
    rowwise() %>%
    mutate(dim_score = sum(ifelse(ap_score > 0, 1, 0),
                           ifelse(dv_score > 0, 1, 0),
                           ifelse(ml_score > 0, 1, 0))) %>%
    ungroup()

#counts of uniform ORs
all_uni %>% 
    group_by(all_score) %>% 
    summarise(count = n()) %>% 
    arrange(desc(all_score))

all_uni %>% 
    group_by(ap_score) %>% 
    summarise(count = n()) %>% 
    arrange(desc(ap_score))

all_uni %>% 
    group_by(dv_score) %>% 
    summarise(count = n()) %>% 
    arrange(desc(dv_score))

all_uni %>% 
    group_by(ml_score) %>% 
    summarise(count = n()) %>% 
    arrange(desc(ml_score))

ggplot(all_uni, aes(all_score, ap_score)) +
    geom_jitter()

#how many ORs are uniform in all dims
ap_uniORs <- all_uni %>% filter(ap_score > 0) %>% pull(gene)
dv_uniORs <- all_uni %>% filter(dv_score > 0) %>% pull(gene)
ml_uniORs <- all_uni %>% filter(ml_score > 0) %>% pull(gene)

alldim_uniORs <- unique(c(ap_uniORs, dv_uniORs, ml_uniORs))
#96 ORs were uniform in a single dim

length(ap_uniORs)
length(dv_uniORs)
length(ml_uniORs)

which(dv_uniORs %in% ap_uniORs)
length(which(dv_uniORs %in% ap_uniORs)) 
#22 of 39 dv uni ORs are in the 71 ap uni ORs
apdv_uniORs <- dv_uniORs[which(dv_uniORs %in% ap_uniORs)]

which(ml_uniORs %in% apdv_uniORs)
length(which(ml_uniORs %in% apdv_uniORs))
#8 of 22 ml uni ORs are in the 22 apdv uni ORs
alldim_overlap_uniORs <- ml_uniORs[which(ml_uniORs %in% apdv_uniORs)]
```

# Split into n groups

```{r, eval=F}
#branch400 <- PlotBranches(400)
#saveRDS(branch400, "~/Desktop/obmap/r_analysis/heatmaps/output/branch400.RDS")
branch400 <- readRDS("~/Desktop/obmap/r_analysis/heatmaps/output/branch400.RDS")

#400 branches, only 127 have >1 OR
#300 brnaches, only 122 have > 1 OR
#200 branches, only 118 have > 1 OR

goodcor400 <- which(branch400$cor > 0.95)
gooddist400 <- which(branch400$avg_dist < 12)
goodset <- goodcor400[which(goodcor400 %in% gooddist400)]

bestcor400 <- which(branch400$cor == max(branch400$cor, na.rm=T))
branch400$heatmaps[bestcor400]

bestdist400 <- which(branch400$avg_dist == min(branch400$avg_dist, na.rm=T))
branch400$`3D`[107]
#find something to define the branch with the highest ranked cor that is also the highest ranked 3d
```

