---
title: "OB UMAPs"
author: "kanazian"
date: "`r Sys.Date()`"
output: html_document
always_allow_html: true
---

```{r setup, message=F}
library(uwot)
library(patchwork)
library(cowplot)
library(plotly)
library(tidyverse)

#OR information
info <- read_csv("~/Desktop/info_210430.csv") %>%
  mutate(tz_vd2 = case_when(tz_val < 2 ~ "Dorsal",
                            tz_val >= 2 ~ "Ventral",
                            is.na(tz_val) ~ ifelse(tan_zone == "unusual", "Unusual", "LowExp")),
         dv_wavg = 22-vd_wavg,
         dv_rank = min_rank(dv_wavg)) 

#3d model predictions
#good_3dpoint <- read_csv("~/Desktop/obmap/r_analysis/3dimOB/output/goodpointORs972_allchemo_listdorML_200820.csv") %>% select(olfrname:MedLat)

#expression weighted mean position across replicates for all dims
meanpos_tb <- read_csv("~/Desktop/obmap/r_analysis/data/heatmaps/meanpos_ompdv22no1315_210429.csv")
```


# 2D UMAP 
## Compute UMAP and add features
```{r, warning=F}
meanpos_mtx <- meanpos_tb %>% select(-olfrname) %>% select(m8_ML:m16_ML) %>% drop_na() %>% as.matrix()
rownames(meanpos_mtx) <- meanpos_tb %>% select(olfrname, m8_ML:m16_ML) %>% drop_na() %>% pull(olfrname)

umap_2d <- umap(meanpos_mtx, 
                     n_neighbors = 20, 
                     learning_rate = 1, 
                     init = "spca") %>% 
  as_tibble() %>%
  mutate(olfrname = rownames(meanpos_mtx)) %>%
  rename("UMAP1" = V1, "UMAP2" = V2) %>%
  left_join(info, by = "olfrname") %>%
  mutate(class_fct = as_factor(class))

#testplot to look at shape
ggplot(umap_2d %>% filter(!is.na(tz_vd))) + 
  geom_point(aes(UMAP1, UMAP2, color = tz_vd), size = 2) +
  ggtitle("Tan DV") +
  scale_color_manual(values = c("red", "blue", "green", "black"))
```


## Does OR class and OE dorsal/ventral position cluster in UMAP?
```{r}
#edit theme_kz for no legend
um2d_class <- ggplot(umap_2d %>% filter(!is.na(class))) + 
  geom_point(aes(UMAP1, UMAP2, color = class_fct), size = 2) +
  scale_color_manual(values = c("red", "black")) +
  theme_bw() +
  theme_kz()

um2d_fi <- ggplot(umap_2d %>% filter(!is.na(fisurface))) + 
  geom_point(aes(UMAP1, UMAP2, color = fisurface), size = 2) +
  scale_color_manual(values = c("black", "red")) +
  theme_bw() +
  theme_kz()

um2d_tzval <- ggplot(umap_2d %>% filter(!is.na(tz_val))) + 
  geom_point(aes(UMAP1, UMAP2, color = tz_val), size = 2) +
  scale_color_viridis_c() +
  theme_bw() +
  theme_kz()

um2d_tzvd <- ggplot(umap_2d %>% filter(!is.na(tz_vd))) + 
  geom_point(aes(UMAP1, UMAP2, color = tz_vd), size = 2) +
  scale_color_manual(values = c("red", "black")) +
  theme_bw() +
  theme_kz()

um2d_momb <- ggplot(umap_2d %>% filter(!is.na(Zolfr_Momb))) + 
  geom_point(aes(UMAP1, UMAP2, color = Zolfr_Momb), size = 2) + 
  scale_color_viridis_c() +
  theme_bw() +
  theme_kz()


## Do individual heatmap dimensions (AP/ML/DV) expression weighted mean position relate to UMAP representation of the 3 combined dimensions?
# umap colored by dim with a regression line indicating dim axis
mp_2D_groups <- umap_2d %>%
  mutate(apmp_bin = round(2*ap_wavg)/2,
         dvmp_bin = round(2*vd_wavg)/2,
         mlmp_bin = round(2*ml_wavg)/2) %>%
  group_by(apmp_bin) %>%
  mutate(apbin_x = mean(UMAP1),
         apbin_y = mean(UMAP2)) %>%
  ungroup() %>%
  group_by(dvmp_bin) %>%
  mutate(dvbin_x = mean(UMAP1),
         dvbin_y = mean(UMAP2)) %>%
  ungroup() %>%
  group_by(mlmp_bin) %>%
  mutate(mlbin_x = mean(UMAP1),
         mlbin_y = mean(UMAP2)) %>%
  ungroup() %>%
  mutate(ap_3 = ifelse(ap_rank < max(ap_rank, na.rm=T)/3, 
                       "apAnt", ifelse(ap_rank > (max(ap_rank, na.rm=T)/3)*2, 
                              "apPos", "apMid")),
         dv_3 = ifelse(vd_rank < max(vd_rank, na.rm=T)/3, 
                       "dvVen", ifelse(vd_rank > (max(vd_rank, na.rm=T)/3)*2, 
                              "dvDor", "dvMid")),
         ml_3 = ifelse(ml_rank < max(ml_rank, na.rm=T)/3, 
                       "mlaMed", ifelse(ml_rank > (max(ml_rank, na.rm=T)/3)*2, 
                              "mlcLat", "mlbMid")),
         combo_3 = str_c(ap_3, dv_3, ml_3, sep = "_")) %>%
  arrange(combo_3) %>% 
  mutate(combo_3fct = as_factor(combo_3)) %>%
  arrange(ap_3) %>%
  mutate(ap_3fct = as_factor(ap_3)) %>%
  arrange(dv_3) %>%
  mutate(dv_3fct = as_factor(dv_3)) %>%
  arrange(ml_3) %>%
  mutate(ml_3fct = as_factor(ml_3))

#ap
um2d_ap <- ggplot(mp_2D_groups) + 
  geom_point(aes(UMAP1, UMAP2, color = ap_wavg), size = 2) + 
  scale_color_viridis_c() +
  theme_bw() +
  theme_kz()

#dv
um2d_vd <- ggplot(mp_2D_groups) + 
  geom_point(aes(UMAP1, UMAP2, color = dv_wavg), size = 2) + 
  scale_color_viridis_c() +
  theme_bw() +
  theme_kz() 

#ml
um2d_ml <- ggplot(mp_2D_groups) + 
  geom_point(aes(UMAP1, UMAP2, color = ml_wavg), size = 2) + 
  scale_color_viridis_c() +
  theme_bw() +
  theme_kz()

#ap with all 3
ggplot(mp_2D_groups) + 
  geom_point(aes(UMAP1, UMAP2, color = ap_wavg), size = 2) + 
  geom_smooth(aes(apbin_x, apbin_y), size = 2, se=F,
              color = "red", span  = 2) +
  geom_smooth(aes(dvbin_x, dvbin_y), size = 2, se=F,
              color = "purple", span  = 2) +
  geom_smooth(aes(mlbin_x, mlbin_y), size = 2, se=F,
              color = "brown", span  = 2) +
  ggtitle("AP mean position with AP binned smooth",
          subtitle = "Red = AP, Purple = DV, Brown = ML") +
  theme_bw() +
  scale_color_viridis_c()

SaveSquarePlots(um2d_class, um2d_fi, um2d_tzval, um2d_tzvd, um2d_momb, um2d_ap, um2d_ml, um2d_vd, path = "~/Desktop/umaps/ompdv22no1315/")
```


## Can we pseudo-represent 3D by combinatorially joining all 3 dimensions split into early, middle, late?  How 
```{r, message=F}
#points colored by combinatorial group
ggplot(mp_2D_groups %>% filter(!is.na(combo_3))) + 
  geom_point(aes(UMAP1, UMAP2, color = combo_3fct), size = 2) + 
  ggtitle("AP, DV, ML combinations as 3 groups per dim",
          subtitle = "Red = AP, Purple = DV, Brown = ML") +
  theme_cowplot() +
  scale_color_viridis_d() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 10))


centroids <- mp_2D_groups %>%
  filter(!is.na(combo_3)) %>%
  group_by(combo_3, combo_3fct) %>%
  summarise(group_1 = mean(UMAP1),
            group_2 = mean(UMAP2)) 

#points, centroids, and smooth lines
ggplot(mp_2D_groups) +
  geom_point(aes(UMAP1, UMAP2, 
                                   color = combo_3fct), size = 2) +  
  geom_smooth(aes(apbin_x, apbin_y), size = 2, se=F,
              color = "red", span  = 0.1) +
  geom_smooth(aes(dvbin_x, dvbin_y), size = 2, se=F,
              color = "purple", span  = 0.1) +
  geom_label(data = centroids, aes(group_1, group_2, 
                 label = as.numeric(combo_3fct), color = combo_3fct),
             size = 5, fill = "grey", fontface = "bold") + 
  ggtitle("AP, DV, ML combinations as 3 groups per dim",
          subtitle = "Red = AP, Purple = DV, Brown = ML") +
  theme_cowplot() +
  scale_color_viridis_d() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 10))
```


# 3D UMAP
## Is the ML dim better represented when data is projected to 3 dimensions?
```{r}
set.seed(42)

umap_3dim <- umap(meanpos_mtx, 
                  n_components = 3,
                  n_neighbors = 30, 
                  learning_rate = 0.5, 
                  init = "spca") %>% 
  as_tibble() %>%
  mutate(olfrname = rownames(meanpos_mtx)) %>%
  rename("UMAP1" = V1, "UMAP2" = V2, "UMAP3" = V3) %>% 
  select(olfrname, everything()) %>%
  left_join(info, by = "olfrname") %>%
  mutate(class_fct = as_factor(class))

mp_3D_groups <- umap_3dim %>%
  mutate(apmp_bin = round(2*ap_wavg)/2,
         dvmp_bin = round(2*dv_wavg)/2,
         mlmp_bin = round(2*ml_wavg)/2) %>%
  group_by(apmp_bin) %>%
  mutate(apbin_x = mean(UMAP1),
         apbin_y = mean(UMAP2),
         apbin_z = mean(UMAP3)) %>%
  ungroup() %>%
  group_by(dvmp_bin) %>%
  mutate(dvbin_x = mean(UMAP1),
         dvbin_y = mean(UMAP2),
         dvbin_z = mean(UMAP3)) %>%
  ungroup() %>%
  group_by(mlmp_bin) %>%
  mutate(mlbin_x = mean(UMAP1),
         mlbin_y = mean(UMAP2),
         mlbin_z = mean(UMAP3)) %>%
  ungroup() %>%
  mutate(ap_3 = ifelse(ap_rank < max(ap_rank, na.rm=T)/3, 
                       "apAnt", ifelse(ap_rank > (max(ap_rank, na.rm=T)/3)*2, 
                              "apPos", "apMid")),
         dv_3 = ifelse(dv_rank < max(dv_rank, na.rm=T)/3, 
                       "dvVen", ifelse(dv_rank > (max(dv_rank, na.rm=T)/3)*2, 
                              "dvDor", "dvMid")),
         ml_3 = ifelse(ml_rank < max(ml_rank, na.rm=T)/3, 
                       "mlaMed", ifelse(ml_rank > (max(ml_rank, na.rm=T)/3)*2, 
                              "mlcLat", "mlbMid")),
         combo_3 = str_c(ap_3, dv_3, ml_3, sep = "_")) %>%
  arrange(combo_3) %>% 
  mutate(combo_3fct = as_factor(combo_3)) %>%
  arrange(ap_3) %>%
  mutate(ap_3fct = as_factor(ap_3)) %>%
  arrange(dv_3) %>%
  mutate(dv_3fct = as_factor(dv_3)) %>%
  arrange(ml_3) %>%
  mutate(ml_3fct = as_factor(ml_3))
```


# AP via 2D and plotly 3D
```{r}
#ap
ggplot(mp_3D_groups) + 
  geom_point(aes(UMAP1, UMAP2, color = ap_wavg), size = 2) + 
  geom_smooth(aes(apbin_x, apbin_y), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("AP mean position with AP binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

ggplot(mp_3D_groups) + 
  geom_point(aes(UMAP1, UMAP3, color = ap_wavg), size = 2) + 
  geom_smooth(aes(apbin_x, apbin_z), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("AP mean position with AP binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

ggplot(mp_3D_groups) + 
  geom_point(aes(UMAP2, UMAP3, color = ap_wavg), size = 2) + 
  geom_smooth(aes(apbin_y, apbin_z), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("AP mean position with AP binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

#interactive 3D with plotly
plot_ly(type = "scatter3d", mode = "markers") %>%
  add_trace(data = mp_3D_groups, x=~UMAP1, y=~UMAP2, z=~UMAP3, 
            color=~ap_wavg,
        marker=list(size = 4, line = list(color = 'black', width = 0.5)),
        text=~paste("gene: ", olfrname), type='scatter3d') %>%
  layout(title = "3D UMAP - Color is AP position")
```


# DV via 2D and plotly 3D
```{r}
#dv
ggplot(mp_3D_groups) + 
  geom_point(aes(UMAP1, UMAP2, color = dv_wavg), size = 2) + 
  geom_smooth(aes(dvbin_x, dvbin_y), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("DV mean position with DV binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

ggplot(mp_3D_groups) + 
  geom_point(aes(UMAP1, UMAP3, color = dv_wavg), size = 2) + 
  geom_smooth(aes(dvbin_x, dvbin_z), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("DV mean position with DV binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

ggplot(mp_3D_groups) + 
  geom_point(aes(UMAP2, UMAP3, color = dv_wavg), size = 2) + 
  geom_smooth(aes(dvbin_y, dvbin_z), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("DV mean position with DV binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

#interactive 3D with plotly
plot_ly(type = "scatter3d", mode = "markers") %>%
  add_trace(data = mp_3D_groups, x=~UMAP1, y=~UMAP2, z=~UMAP3, 
            color=~dv_wavg,
        marker=list(size = 4, line = list(color = 'black', width = 0.5)),
        text=~paste("gene: ", olfrname), type='scatter3d') %>%
  layout(title = "3D UMAP - Color is DV position")
```


# ML via 2D and plotly 3D
```{r}
#ml
ggplot(mp_3D_groups) +
  geom_point(aes(UMAP1, UMAP2, color = ml_mp), size = 2) + 
  geom_smooth(aes(mlbin_x, mlbin_y), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("ML mean position with ML binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

ggplot(mp_3D_groups) + 
  geom_point(aes(UMAP1, UMAP3, color = ml_mp), size = 2) + 
  geom_smooth(aes(mlbin_x, mlbin_z), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("ML mean position with DV binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

ggplot(mp_3D_groups) + 
  geom_point(aes(UMAP2, UMAP3, color = ap_mp), size = 2) + 
  geom_smooth(aes(mlbin_y, mlbin_z), size = 2, se=F,
              color = "red", span  = 0.1) +
  ggtitle("ML mean position with ML binned smooth") +
  theme_cowplot() +
  scale_color_viridis_c()

#interactive 3D with plotly
plot_ly(type = "scatter3d", mode = "markers") %>%
  add_trace(data = mp_3D_groups, x=~UMAP1, y=~UMAP2, z=~UMAP3, 
            color=~ml_mp,
        marker=list(size = 4, line = list(color = 'black', width = 0.5)),
        text=~paste("gene: ", olfrname), type='scatter3d') %>%
  layout(title = "3D UMAP - Color is ML position")
```

# combinatorial dim groups in 3D
```{r}
#points colored by combinatorial group
ggplot(mp_3D_groups %>% filter(!is.na(combo_3))) + 
  geom_point(aes(UMAP1, UMAP2, color = combo_3fct), size = 2) + 
  ggtitle("AP, DV, ML combinations as 3 groups per dim") +
  theme_cowplot() +
  scale_color_viridis_d() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 10))

ggplot(mp_3D_groups %>% filter(!is.na(combo_3))) + 
  geom_point(aes(UMAP1, UMAP3, color = combo_3fct), size = 2) + 
  ggtitle("AP, DV, ML combinations as 3 groups per dim") +
  theme_cowplot() +
  scale_color_viridis_d() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 10))

ggplot(mp_3D_groups %>% filter(!is.na(combo_3))) + 
  geom_point(aes(UMAP2, UMAP3, color = combo_3fct), size = 2) + 
  ggtitle("AP, DV, ML combinations as 3 groups per dim") +
  theme_cowplot() +
  scale_color_viridis_d() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 8),
        legend.title = element_text(size = 10))

centroids_3D <- mp_3D_groups %>%
  filter(!is.na(combo_3)) %>%
  group_by(combo_3, combo_3fct) %>%
  summarise(group_1 = mean(UMAP1),
            group_2 = mean(UMAP2),
            group_3 = mean(UMAP3)) 

#points and centroids
plot_ly(type = "scatter3d", mode = "markers") %>%
  add_trace(data = centroids_3D, x=~group_1, y=~group_2, z=~group_3, 
            color=~as.numeric(combo_3fct),
        marker=list(size = 8, line = list(color = 'black', width = 0.5)),
        text=~paste("combo_dim: ", combo_3fct), type='scatter3d') %>%  
  add_trace(data = mp_3D_groups, x=~UMAP1, y=~UMAP2, z=~UMAP3, 
            color=~as.numeric(combo_3fct), opacity = 0.5,
        marker=list(size = 4, line = list(color = 'black', width = 0.5)),
        text=~paste("combo_dim: ", combo_3fct), type='scatter3d')
```

